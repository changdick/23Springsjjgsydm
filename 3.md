# 第三章 图
## 1. 图的基本概念
图的逻辑结构是一个元素可以有一个或多个直接前驱和一个或多个直接后继。  
图的定义就是顶点集和边集。  
记住一些概念：无向图和有向图，生成树，带权重图（又称为网）和不带权图
## 2. 图的两种存储
### 邻接矩阵
图的邻接矩阵存储是用方矩阵来表示两个顶点间有没有边。对于n个顶点的图，对每个顶点编号并建一个n阶方阵，行号和列号和顶点对应上，那么矩阵元素 $a_{ij}$表示i号顶点和j号顶点之间的邻接关系。比如不带权无向图1号顶点和3号顶点间有一条边，则 $a_{13},a_{31}$的值设置为1，1号顶点和4号顶点之间没有边，就把 $a_{14}$设置为0.这样整个矩阵由0和1组成，就可以表示存储下这张图。  
图的矩阵存储分两种，带权和不带权。对于不带权的，矩阵元素为0和1来表示有没有边。而对于边带权重的图，把 $a_{ij}$设置为i号顶点到j号顶点的距离，即它们之间边的权重。对于两个点没有边的，就说他们距离无穷大，对应矩阵元素设置成 $\infty$ (可以宏定义一个很大的数来实现)
实现如下，不过先别管了：
<details><summary>点击折叠</summary>
<p>
  
```c
//数据类型的定义
typedef struct matrixgraph{
    int vertex;          //顶点的数量
    int ** matrix;       //一个int型指针的指针，其实会变成一个矩阵，跟待会建图的函数有关系
}graphmat,graphweightmat;     //graphmat表示不带权的，graphweightmat表示带权的

//建不带边图的函数
//返回一个没有边的图
graphmat * createMatgraph(int nodes){
    graphmat * graph = (graphmat*)malloc(sizeof(graphmat));
    graph->vertex = nodes;
    //下面几行构建矩阵
    graph->matrix = (int**) malloc(sizeof (int *) * nodes);
    for (int i = 0; i < nodes; ++i) {
        graph->matrix[i] = (int*) malloc(sizeof(int) * nodes);
    }
    //矩阵置0
    for (int i = 0; i < nodes; ++i) {
        for (int j = 0; j < nodes; ++j) {
            if(i == j)  graph->matrix[i][j] = 0;
            else    graph->matrix[i][j] = Infinit;   //Infinit是宏定义的量 这另个语句改成不做条件判断，全部赋成0就可以是不带权图
        }
    }
    return graph;
}

//添加边的函数，这边是以带权的为例子，那如果是不带权值的，就设置成1就好了
//添加一条有向带权值边
}void addweightdirectionaledgeMat(graphmat * graph, int src, int dest, int weight){
    graph->matrix[src][dest] = weight;
}
//如果要改成无向很简单，从source指dest有，从dest指source也有就行了
void addweightedgeMat(graphmat * graph, int src, int dest, int weight){
    graph->matrix[src][dest] = weight;
    graph->matrix[dest][src] = weight;
```
  
</p>
</details>

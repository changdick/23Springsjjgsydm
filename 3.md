# 第三章 图
## 1. 图的基本概念
图的逻辑结构是一个元素可以有一个或多个直接前驱和一个或多个直接后继。  
图的定义就是顶点集和边集。  
记住一些概念：无向图和有向图，生成树，带权重图（又称为网）和不带权图
## 2. 图的两种存储
### 邻接矩阵
图的邻接矩阵存储是用方矩阵来表示两个顶点间有没有边。对于n个顶点的图，对每个顶点编号并建一个n阶方阵，行号和列号和顶点对应上，那么矩阵元素 $a_{ij}$表示i号顶点和j号顶点之间的邻接关系。比如不带权无向图1号顶点和3号顶点间有一条边，则 $a_{13},a_{31}$的值设置为1，1号顶点和4号顶点之间没有边，就把 $a_{14}$设置为0.这样整个矩阵由0和1组成，就可以表示存储下这张图。  
图的矩阵存储分两种，带权和不带权。对于不带权的，矩阵元素为0和1来表示有没有边。而对于边带权重的图，把 $a_{ij}$设置为i号顶点到j号顶点的距离，即它们之间边的权重。对于两个点没有边的，就说他们距离无穷大，对应矩阵元素设置成 $\infty$ (可以宏定义一个很大的数来实现)
实现如下，不过先别管了：
<details><summary>点击折叠</summary>
<p>
  
```c
//数据类型的定义
typedef struct matrixgraph{
    int vertex;          //顶点的数量
    int ** matrix;       //一个int型指针的指针，其实会变成一个矩阵，跟待会建图的函数有关系
}graphmat,graphweightmat;     //graphmat表示不带权的，graphweightmat表示带权的

//建不带边图的函数
//返回一个没有边的图
graphmat * createMatgraph(int nodes){
    graphmat * graph = (graphmat*)malloc(sizeof(graphmat));
    graph->vertex = nodes;
    //下面几行构建矩阵
    graph->matrix = (int**) malloc(sizeof (int *) * nodes);
    for (int i = 0; i < nodes; ++i) {
        graph->matrix[i] = (int*) malloc(sizeof(int) * nodes);
    }
    //矩阵置0
    for (int i = 0; i < nodes; ++i) {
        for (int j = 0; j < nodes; ++j) {
            if(i == j)  graph->matrix[i][j] = 0;
            else    graph->matrix[i][j] = Infinit;   //Infinit是宏定义的量 这另个语句改成不做条件判断，全部赋成0就可以是不带权图
        }
    }
    return graph;
}

//添加边的函数，这边是以带权的为例子，那如果是不带权值的，就设置成1就好了
//添加一条有向带权值边
}void addweightdirectionaledgeMat(graphmat * graph, int src, int dest, int weight){
    graph->matrix[src][dest] = weight;
}
//如果要改成无向很简单，从source指dest有，从dest指source也有就行了
void addweightedgeMat(graphmat * graph, int src, int dest, int weight){
    graph->matrix[src][dest] = weight;
    graph->matrix[dest][src] = weight;
```
  
</p>
</details>

### 邻接表
邻接表是一个数组，数组的每个元素都是链表，就用数组下标来表示顶点，而访问数组元素i后是对应链表的头指针，链表的每个结点都是点i所邻接到的结点。邻接表的每一个指针，都可以看作是从点i出发邻接到对应点的边。比如有n个点，就申请长度n的数组，n个头指针对应放进去，下标i的头指针对应的链表单元全是i号顶点邻接到的结点。  
实现：邻接表是一个数组，链表的数组，图有几个结点，数组就有几个元素。每一个元素都是一条链表，我们只需要他的头指针head。也就是说，邻接表就是head指针的数组。链表的单元是该节点的邻居节点。我们不必设置头结点，没必要。我们插入新结点，就用头插法就好了。至于这个head指针，作为图，我们可以用struct包装一下。
<details><summary>点击折叠</summary>
  
```c
//邻接表中链表的单元
typedef struct edge{
    int dest;            //所指向的目标顶点
    int weight;          //这个边的权重
    struct edge* next;   //同起点的下一条边
}edge;                   //这个取名的含义是，上邻接表的指针都相当于是从同一起点出发的边。要访问相邻顶点，比如有edge* p，就用 p->dest 就好了

//邻接表的数据类型(为了好看，不要让邻接表直接就是edge head[num_Vertix]，当然它就是)，包装这一下只是为了邻接表单元有个自己的类型
typedef struct adjlistunit{
    edge* head;
}adjlistunit;

//图就是以邻接表的形式存在的，所以我们定义一下图
typedef struct graphINadj{
    int num_nodes;          //图顶点的个数
    adjlistunit* adjlist;   //由“邻接表单元”组成的邻接表，这是个指针型，其实是个数组，看下面建图的函数就明白了
}graphadj;

//初始化有n个结点的图，不带边，函数读入要创建的图的顶点个数
graphadj* graphinit(int n){
    graphadj * graph = (graphadj*)malloc(sizeof (graphadj));      //申请内存空间
    graph->num_nodes = n;                                        //顶点个数设置为n
    adjlistunit * adjlist = (adjlistunit*)malloc(n*sizeof (adjlistunit));   
    graph->adjlist = adjlist;                                           //这两句创建邻接表
    for (int i = 0; i < n; ++i) {
        graph->adjlist[i].head = NULL;  //初始化全部没有边
    }
    return graph;
}

//添加一条有向边  函数读入 起点号数src(source) 和 终点号数dest(destination)
void directedge(graphadj* graph, int src, int dest){
    edge* newedge = (edge*)malloc(sizeof(edge));     //申请一个新边的类型
    newedge->dest = dest;                            //指定终点
    newedge->next = graph->adjlist[src].head;        
    graph->adjlist[src].head = newedge;              //这两句是头插法，合起来就是放到邻接表相应的链表中
}

//如果是加无向边，就是比有向边要指过来，又指过去
void addedge(graphadj* graph, int src, int dest){
    edge* newedge = (edge*)malloc(sizeof(edge));
    newedge->dest = dest;
    newedge->next = graph->adjlist[src].head;
    graph->adjlist[src].head = newedge;
    //如果是无向图要再加一条对称边
    newedge = (edge*)malloc(sizeof(edge));
    newedge->dest = src;
    newedge->next = graph->adjlist[dest].head;
    graph->adjlist[dest].head = newedge;
}
//添加一条有向的有权重边，只比上面那个多了一个设置权重的环节，上面那个加边函数是说刚开始一些图不考虑带权就先简单一点
void directweightedge(graphadj* graph, int src, int dest, int weight){
    edge* newedge = (edge*)malloc(sizeof(edge));
    newedge->dest = dest;
    newedge->weight = weight;                  //设置边权重
    newedge->next = graph->adjlist[src].head;
    graph->adjlist[src].head = newedge;  
}
```
 
<details>

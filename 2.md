# 第二章 树
## 1. 二叉树的性质
二叉树有五个重要性质。先补充一下二叉树的一些概念。  
树的抽象定义；树这种结构的定义在于**递归性**，一个元素的后继互不相交的几部分，且每一个部分都是树  
树高(深度)：有一个节点的树，树高为1，有两个节点的树，树高为2。以根节点为第一层，往下数有几层，树高就为几。  
二叉树：树的结点最多有2个孩子，即孩子可以有0个，1个，2个。二叉树最多就是两个孩子，左孩子和右孩子，所以单节点带两个指针域就可以定义二叉树的结点类型并实现。    
完全二叉树：完全二叉树是向左对齐的，一层没满不能起下一层，没有左孩子不能有右孩子。因此他有线性编号的特性。  
#### 1和2 二叉树的计数性质
1)二叉树的单层结点数目满足：第 $i$ 层最多有 $2^{i-1}$ 个结点  
2)二叉树的的层数为h，那他的结点总数最多为 $2^h-1$ 个

很简单两个性质，图一画，等比数列求和公式，一下就推导出来了
#### 3 重要性质：0度2度结点关系（掌握证明）
对一个二叉树而言，其0度结点个数为 $n_0$ ,2度结点个数为 $n_2$ ,它们的关系是 $n_0 = n_2 +1$

**记忆技巧**： 满二叉树是一个特例，假设他有h层，0度结点全在第h层， $n_0=2^{h-1}$ ,第1到第h-1层也是一个满二叉树,全是2度结点, $n_2 = 2^{h-1} -1$ ，一目了然的 

**掌握证明**：证明方法：设 $n_0$, $n_1$, $n_2$, 利用 全度数之和 = 边数 ， 边数 = 结点数-1，一代入就证出来了

#### 4 完全二叉树的深度公式
结点个数n，直接以2为底取对数， 整的上界就是深度（树高）。

**推导方法**：设树高为k，那么k-1层必满，k层可以满可以不满，所以n的大小必大于高k-1层的满二叉树结点数，小于等于高为k的满二叉树的结点数，后对此式子变形，得到 $\log_{2}{n}$ 介于h-1和h之间（左闭右开），稍微画个图就更清楚了，显然h就是 $\log_{2}{n}$ 向上取整， 或者 $\log_{2}{n}$向下取整再+1. 即 $\lceil\log_{2}{n}\rceil$,或 $\lfloor\log_{2}{n}\rfloor+1$
#### 5 完全二叉树的结点序号性质
完全二叉树其实是有序的。以根节点为1号，接下来从左向右有序编号，那么有以下性质：  
1)结点i如果有左孩子一定是 2i 号， 如果有右孩子一定是 2i + 1 号  
2)结点j如果要找他的双亲，双亲编号一定是 j / 2   (c语言int计算是这样，意思就是整数除 j//2)

注：性质5是完全二叉树的结点序号性质， 这个性质表明完全二叉树可以成为线性结构，因为对i结点我们知道它的孩子节点和双亲结点各是多少。这个性质可以用来在完全二叉树求结点个数，应用在堆排序。

## 2. 二叉树的实现和遍历操作 
>二叉树的实现去tree1里面找 [链接在这里](/tree1/binarytreea.h)
### 1) 二叉树的简单实现
二叉树的实现一定要理解递归的思想，树本身就是递归结构，树的每个结点都是一个树根，左孩子是NULL也是树，是空树。单个节点的定义只需要数据域、左右孩子的指针域
```
typedef struct BTnode{
    char data;                        //数据域
    struct BTnode* leftchild;         //左孩子（子树）的指针
    struct BTnode* rightchild;        //右孩子（子树）的指针
}Binarytree;                //Binarytree 既是结点的型，也是我们作为整个树的型，他就是一个树（我们只需要知道根、左子树、右子树）就掌握了一棵树
```
下面创建一棵树，我们操控到一棵树是通过根节点指针，所以建树要返回根节点指针给我们。建树的函数就是申请内存空间、返回地址给我们。
 ```
 Binarytree* newnode(char dataval){
    Binarytree * node = (Binarytree*)malloc(sizeof (Binarytree));        //向系统申请一个树节点类型的空间，即内存中创建一个结点
    node->data = dataval;                                                //把data值读进data域里
    node->leftchild = NULL;                                              //新结点左右孩子一律初始化为空
    node->rightchild = NULL;
    return node;
}                                                                        //这个函数是读取一个我们要的data，返回一个存了该data的二叉树结点。
```
我们只要人工反复调用这个函数，就可以建立一个我们想要的二叉树了。
### 2) 二叉树的四种遍历
二叉树的四种遍历为先根遍历、中根遍历、后根遍历、层次遍历。或则先序、中序、后序、层次遍历。前三种遍历，我们先大概看一下含义。  
先序遍历：先访问根，再访问左子树，再访问右子树。   中序、后序同理的。  
这个表述说明：在这三种遍历方法中，是尊重着**递归结构**的。因此实现很简单，对于一个树过来，我们递归调用函数，中序遍历就是{先遍历左子树，再访问根，再遍历右子树}  
即：比如中根遍历：遍历(树){ 调用遍历函数遍历左子树;访问根;调用遍历函数遍历右子树 } 自然就完成了
```
void intravel(Binarytree* BTree){
    if(BTree){                             //注意：这里做了一个条件判断，其实是递归的出口：叶子节点再调用就是空树，空树过不了判断就结束了
        intravel(BTree->leftchild);        //调用遍历函数遍历左子树
        printf(" %c",BTree->data);         //访问根
        intravel(BTree->rightchild);       //调用遍历函数遍历右子树 
    }                                      //如果要改成先序、后序遍历，只需改变访问根那行代码的位置
}
```
写递归函数的技巧：一、首先得有出口，得有基本情况，所以从基本情况写起。这里的基本情况是：如果树是空的，它的遍历就自动就完成了。`if(tree == NULL)   ;(do nothing)`，这就是基础情况，确定基础情况，才不会走向无限递归。 二、递归地调用的时候看下面三个要点，以上面`intravel(BTree->leftchild)`为例子    
1. 写这一行要把函数高度抽象，不要管函数怎么实现的，只管他会完成什么事，返回什么。我们就当interval已经实现了，就是可以帮我们完成左子树遍历。
2. 写这一行的时候，就当intravel(BTree->leftchild)是对的可行的。不要去想这个调用里发生了什么，相信它帮我们完成了左子树遍历。
3. 递归中要验证f(n)可行，只需验证f(n-1)可行，最终只需验证f(0)（基础情况）没有问题，整个递归就没有问题。
##### 层序遍历
第四种遍历是二叉树的层次遍历。层次遍历借助队列来实现，算法简单就是，根节点进队列，此后循环，每次出队列的同时做访问并让出队列的这个结点的左孩子、右孩子依次进队列。当队列空了就说明遍历完了。
要实现二叉树的层次遍历，要借助一个队列。存储树结点的队列实现好了，直接引一个头文件`#include "queue.h"`
```
void CengcCiTravle(Binarytree* BTree){
    Queue  * queue = createnewqueue();                //声明一个队列
    enqueue(queue,BTree);                             //从树的根节点开始先进队列
    while(!queueempty(queue)){                        //进入循环，每次做一次出队列，并把出队列的这个结点访问，再把它左、右孩子进队列
        Binarytree * current = dequeue(queue);         //出队列
        printf(" %c",current->data);                     //访问
        if(current->leftchild)    enqueue(queue,current->leftchild);          //左右孩子依次进队列
        if(current->rightchild) enqueue(queue,current->rightchild);          //注：if的条件这样写，意思就是当此树非空才会进队列，此树为空就到不进队列
    }//当队列没有元素了，就说明层次遍历结束了
}
```

#### 题型：已知两种遍历序列，确定出二叉树
利用二叉树的前缀、中缀、后缀表达式确定二叉树。要确定一个二叉树，必须知道中序遍历，然后再知道前序遍历和后序遍历一种即可。
### 3) 线索二叉树
#### 线索二叉树的提出
可以证明(用性质3)，当二叉树以我们定义的那种两指针域形式，n个结点的二叉树会有n+1个空指针域没有被使用。线索二叉树就是充分利用了这些空指针域，让遍历等操作更好实现.   
在没有线索的时候，对于一个结点，如果它有右孩子，我们有办法找他的中序后继；如果他有左孩子，我们有办法找他的中序前驱。但如果没有的话，我们找不了。而线索就是在找不了的情况下直接帮我们指过去.这就意味着：对于一个线索二叉树，我们肯定知道任意一个结点的中序后继，那么我们有办法简单地实现中序遍历。而且，我们肯定知道任意一个节点的中序前驱，意味着我们甚至可以倒着中序遍历.
#### 线索二叉树的构建
##### 先分析线索二叉树的结构特点
节点定义：线索二叉树的节点要定义5个域，分别是给左右孩子指针各增加一个tag域，用来表示左孩子和右孩子是否存在。当左孩子存在的时候，左指针的意义就是指向左孩子。当左孩子不存在的时候，左指针就是指向中序前驱。    
此外，增加了一个头结点，中序遍历首元的前驱认为是头结点，中序末元的后继认为是头结点。头结点左孩子有且是真树根，头结点右孩子有且是他自己。  
##### 以中序线索二叉树为例，创建线索二叉树的过程就是中序线索化的过程
实现的代码 [点这里tp过去](/tree1/threadbinarytree.h)  
首先得创建一个普通的二叉树，就是没有线索化的普通二叉树。然后对他进行初始化，加上头结点，头结点的左孩子是树根，右孩子是自己。紧接着调用中序线索化的函数，完成中序线索化的操作。它里面是这样的：  
一个递归调用的Inthread函数，他所做的其实是在用两个结点保持前驱后继的关系遍历二叉树，检查节点并在需要加线索的位置加线索。
##### 实现方式的具体解释
先不说

#### 线索二叉树上找中序后继
之所以先讲线索二叉树的构建，是因为我们首先得有个线索二叉树，才好讨论其找后继、遍历的算法。现在有了线索二叉树，问题就来到如何在线索二叉树上返回任意节点的中序后继。  
Inordernext函数读入一个节点，返回其中序后继。如何实现它呢?  (头文件里找这个函数看代码)

首先分析：一个节点有两种情况：有右孩子和右孩子为空。如果右孩子为空，即righttag值为0时，右孩子指针就是指向了中序后继结点。如果右孩子是确实有的。那么中序后继就是右子树的最左叶子。
因此，判断右tag的值，为0时直接就是右指针所指，为1时先走到右孩子，然后一直往左走到最左结点，就找到了。
#### 线索二叉树的中序遍历
由于已经实现了Inordernext函数，这个函数很有意义，因为它总能告诉我们中序后继是谁。那我们只需要从头结点开始，一直用Inordernext来找到中序后继访问过去，就可以了。
代码是treadinordertravel函数。

#### 线索二叉树插结点的线索修正
当线索二叉树插入节点的时候，

# 第二章 树
## 1. 二叉树的性质
二叉树有五个重要性质。先补充一下二叉树的一些概念。  
树的抽象定义；树这种结构的定义在于**递归性**，一个元素的后继互不相交的几部分，且每一个部分都是树  
树高(深度)：有一个节点的树，树高为1，有两个节点的树，树高为2。以根节点为第一层，往下数有几层，树高就为几。  
二叉树：树的结点最多有2个孩子，即孩子可以有0个，1个，2个。二叉树最多就是两个孩子，左孩子和右孩子，所以单节点带两个指针域就可以定义二叉树的结点类型并实现。    
完全二叉树：完全二叉树是向左对齐的，一层没满不能起下一层，没有左孩子不能有右孩子。因此他有线性编号的特性。  
#### 1和2 二叉树的计数性质
1)二叉树的单层结点数目满足：第 $i$ 层最多有 $2^{i-1}$ 个结点  
2)二叉树的的层数为h，那他的结点总数最多为 $2^h-1$ 个

很简单两个性质，图一画，等比数列求和公式，一下就推导出来了
#### 3 重要性质：0度2度结点关系（掌握证明）
对一个二叉树而言，其0度结点个数为 $n_0$ ,2度结点个数为 $n_2$ ,它们的关系是 $n_0 = n_2 +1$

**记忆技巧**： 满二叉树是一个特例，假设他有h层，0度结点全在第h层， $n_0=2^{h-1}$ ,第1到第h-1层也是一个满二叉树,全是2度结点, $n_2 = 2^{h-1} -1$ ，一目了然的 

**掌握证明**：证明方法：设 $n_0$, $n_1$, $n_2$, 利用 全度数之和 = 边数 ， 边数 = 结点数-1，一代入就证出来了

#### 4 完全二叉树的深度公式
结点个数n，直接以2为底取对数， 整的上界就是深度（树高）。

**推导方法**：设树高为k，那么k-1层必满，k层可以满可以不满，所以n的大小必大于高k-1层的满二叉树结点数，小于等于高为k的满二叉树的结点数，后对此式子变形，得到 $\log_{2}{n}$ 介于h-1和h之间（左闭右开），稍微画个图就更清楚了，显然h就是 $\log_{2}{n}$ 向上取整， 或者 $\log_{2}{n}$向下取整再+1. 即 $\lceil\log_{2}{n}\rceil$,或 $\lfloor\log_{2}{n}\rfloor+1$
#### 5 完全二叉树的结点序号性质
完全二叉树其实是有序的。以根节点为1号，接下来从左向右有序编号，那么有以下性质：  
1)结点i如果有左孩子一定是 2i 号， 如果有右孩子一定是 2i + 1 号  
2)结点j如果要找他的双亲，双亲编号一定是 j / 2   (c语言int计算是这样，意思就是整数除 j//2)

注：性质5是完全二叉树的结点序号性质， 这个性质表明完全二叉树可以成为线性结构，因为对i结点我们知道它的孩子节点和双亲结点各是多少。这个性质可以用来在完全二叉树求结点个数，应用在堆排序。

## 2. 二叉树的实现和遍历操作 
>二叉树的实现去tree1里面找 [链接在这里](/tree1/binarytreea.h)
### 1) 二叉树的简单实现
二叉树的实现一定要理解递归的思想，树本身就是递归结构，树的每个结点都是一个树根，左孩子是NULL也是树，是空树。单个节点的定义只需要数据域、左右孩子的指针域
```c
typedef struct BTnode{
    char data;                        //数据域
    struct BTnode* leftchild;         //左孩子（子树）的指针
    struct BTnode* rightchild;        //右孩子（子树）的指针
}Binarytree;                //Binarytree 既是结点的型，也是我们作为整个树的型，他就是一个树（我们只需要知道根、左子树、右子树）就掌握了一棵树
```
下面创建一棵树，我们操控到一棵树是通过根节点指针，所以建树要返回根节点指针给我们。建树的函数就是申请内存空间、返回地址给我们。
 ```c
 Binarytree* newnode(char dataval){
    Binarytree * node = (Binarytree*)malloc(sizeof (Binarytree));        //向系统申请一个树节点类型的空间，即内存中创建一个结点
    node->data = dataval;                                                //把data值读进data域里
    node->leftchild = NULL;                                              //新结点左右孩子一律初始化为空
    node->rightchild = NULL;
    return node;
}                                                                        //这个函数是读取一个我们要的data，返回一个存了该data的二叉树结点。
```
我们只要人工反复调用这个函数，就可以建立一个我们想要的二叉树了。
### 2) 二叉树的四种遍历
二叉树的四种遍历为先根遍历、中根遍历、后根遍历、层次遍历。或则先序、中序、后序、层次遍历。前三种遍历，我们先大概看一下含义。  
先序遍历：先访问根，再访问左子树，再访问右子树。   中序、后序同理的。  
这个表述说明：在这三种遍历方法中，是尊重着**递归结构**的。因此实现很简单，对于一个树过来，我们递归调用函数，中序遍历就是{先遍历左子树，再访问根，再遍历右子树}  
即：比如中根遍历：遍历(树){ 调用遍历函数遍历左子树;访问根;调用遍历函数遍历右子树 } 自然就完成了
```c
void intravel(Binarytree* BTree){
    if(BTree){                             //注意：这里做了一个条件判断，其实是递归的出口：叶子节点再调用就是空树，空树过不了判断就结束了
        intravel(BTree->leftchild);        //调用遍历函数遍历左子树
        printf(" %c",BTree->data);         //访问根
        intravel(BTree->rightchild);       //调用遍历函数遍历右子树 
    }                                      //如果要改成先序、后序遍历，只需改变访问根那行代码的位置
}
```
写递归函数的技巧：一、首先得有出口，得有基本情况，所以从基本情况写起。这里的基本情况是：如果树是空的，它的遍历就自动就完成了。`if(tree == NULL)   ;(do nothing)`，这就是基础情况，确定基础情况，才不会走向无限递归。 二、递归地调用的时候看下面三个要点，以上面`intravel(BTree->leftchild)`为例子    
1. 写这一行要把函数高度抽象，不要管函数怎么实现的，只管他会完成什么事，返回什么。我们就当interval已经实现了，就是可以帮我们完成左子树遍历。
2. 写这一行的时候，就当intravel(BTree->leftchild)是对的可行的。不要去想这个调用里发生了什么，相信它帮我们完成了左子树遍历。
3. 递归中要验证f(n)可行，只需验证f(n-1)可行，最终只需验证f(0)（基础情况）没有问题，整个递归就没有问题。
##### 层序遍历
第四种遍历是二叉树的层次遍历。层次遍历借助队列来实现，算法简单就是，根节点进队列，此后循环，每次出队列的同时做访问并让出队列的这个结点的左孩子、右孩子依次进队列。当队列空了就说明遍历完了。
要实现二叉树的层次遍历，要借助一个队列。存储树结点的队列实现好了，直接引一个头文件`#include "queue.h"`
```c
void CengcCiTravle(Binarytree* BTree){
    Queue  * queue = createnewqueue();                //声明一个队列
    enqueue(queue,BTree);                             //从树的根节点开始先进队列
    while(!queueempty(queue)){                        //进入循环，每次做一次出队列，并把出队列的这个结点访问，再把它左、右孩子进队列
        Binarytree * current = dequeue(queue);         //出队列
        printf(" %c",current->data);                     //访问
        if(current->leftchild)    enqueue(queue,current->leftchild);          //左右孩子依次进队列
        if(current->rightchild) enqueue(queue,current->rightchild);          //注：if的条件这样写，意思就是当此树非空才会进队列，此树为空就到不进队列
    }//当队列没有元素了，就说明层次遍历结束了
}
```

#### 题型：已知两种遍历序列，确定出二叉树
利用二叉树的前缀、中缀、后缀表达式确定二叉树。要确定一个二叉树，必须知道中序遍历，然后再知道前序遍历和后序遍历一种即可。
##### 技巧：先序遍历的第一个肯定是树根，后序遍历的最后一个肯定是树根
方法： 先根据先序或后续判断出树根是谁，然后到中序序列中**找到树根**，这样就**知道了左子树和右子树**是谁。对左子树和右子树，对应两种序列，**递归**做上面过程。

## 3. 线索二叉树
#### 线索二叉树的提出
可以证明(用性质3)，当二叉树以我们定义的那种两指针域形式，n个结点的二叉树会有n+1个空指针域没有被使用。线索二叉树就是充分利用了这些空指针域，让遍历等操作更好实现.   
在没有线索的时候，对于一个结点，如果它有右孩子，我们有办法找他的中序后继；如果他有左孩子，我们有办法找他的中序前驱。但如果没有的话，我们找不了。而线索就是在找不了的情况下直接帮我们指过去.这就意味着：对于一个线索二叉树，我们肯定知道任意一个结点的中序后继，那么我们有办法简单地实现中序遍历。而且，我们肯定知道任意一个节点的中序前驱，意味着我们甚至可以倒着中序遍历.
#### 线索二叉树的构建
##### 先分析线索二叉树的结构特点
节点定义：线索二叉树的节点要定义5个域，分别是给左右孩子指针各增加一个tag域，用来表示左孩子和右孩子是否存在。当左孩子存在的时候，左指针的意义就是指向左孩子。当左孩子不存在的时候，左指针就是指向中序前驱。    
此外，增加了一个头结点，中序遍历首元的前驱认为是头结点，中序末元的后继认为是头结点。头结点左孩子有且是真树根，头结点右孩子有且是他自己。  
##### 以中序线索二叉树为例，创建线索二叉树的过程就是中序线索化的过程
实现的代码 [点这里tp过去](/tree1/threadbinarytree.h)  
首先得创建一个普通的二叉树，就是没有线索化的普通二叉树。然后对他进行初始化，加上头结点，头结点的左孩子是树根，右孩子是自己。紧接着调用中序线索化的函数，完成中序线索化的操作。它里面是这样的：  
一个递归调用的Inthread函数，他所做的其实是在用两个结点保持前驱后继的关系遍历二叉树，检查节点并在需要加线索的位置加线索。
##### 实现方式的具体解释
先不说

#### 线索二叉树上找中序后继
之所以先讲线索二叉树的构建，是因为我们首先得有个线索二叉树，才好讨论其找后继、遍历的算法。现在有了线索二叉树，问题就来到如何在线索二叉树上返回任意节点的中序后继。  
Inordernext函数读入一个节点，返回其中序后继。如何实现它呢?  (头文件里找这个函数看代码)

首先分析：一个节点有两种情况：有右孩子和右孩子为空。如果右孩子为空，即righttag值为0时，右孩子指针就是指向了中序后继结点。如果右孩子是确实有的。那么中序后继就是右子树的最左叶子。
因此，判断右tag的值，为0时直接就是右指针所指，为1时先走到右孩子，然后一直往左走到最左结点，就找到了。
#### 线索二叉树的中序遍历
由于已经实现了Inordernext函数，这个函数很有意义，因为它总能告诉我们中序后继是谁。那我们只需要从头结点开始，一直用Inordernext来找到中序后继访问过去，就可以了。
代码是treadinordertravel函数。

#### 线索二叉树插结点的线索修正
当线索二叉树插入节点的时候，线索都会改变，所以要有特别的修正操作。  
比如把R插入S的右孩子位置，不管S本来有没有右孩子，我们知道以下事实：  
R要当S的右孩子              ——    S的右孩子是R                     `S->rchild = R; S->rtag = 1;`
R要继承S的后继              ——    R的右孩子、右孩子tag与S一样       `R->rchild = S->rchild; R->rtag = S->rtag;`
R肯定没有左孩子，S是其前驱   ——    R的左孩子是线索到S                `R->lchild = S; R->ltag = 0;`
这三个肯定是固定操作, 上面六个语句肯定是固定的。但现在最后一个问题在于，S如果本来有孩子的话，S的中序后继即他的右子树最左叶子会线索一条到S，我们应该把他改成线索到R。  
这个解决很简单，因为R完全继承了S的后继，所以我们判断当R有右孩子时，直接用Inordernext(R)找到这个中序后继结点，把它中序前驱(左孩子)改成R即可。

#### 线索二叉树的题目
1. 判断是不是某种遍历顺序的线索二叉树
2. 判断某个节点的左/右指针应该指向谁
重点放在线索二叉树的概念，线索化的规则、操作，实现怎么搞的就别管了。

## 4. 哈夫曼树
#### 哈夫曼树和哈夫曼编码
哈夫曼编码问题：给几个字母，以某频次出现在文本中，现在要用1和0编码这个文本，要找到最好的编码方案。哈夫曼编码就是解决这个问题，用到的方法就是构建哈夫曼树。  
哈夫曼树：所有结点带权值，表示一个从根到这里一个路径的权重。这样加权路径长就有意义，研究整个树的带权路径长什么时候最小是很有价值的。带权路径长最小的树就是哈夫曼树。结点是奇数个，叶子比二度结点多1个，没有1度结点。这与他的构造有关系。
构造哈夫曼树：拿到n个结点，每次取两个加出一个新的。 n个点构造哈夫曼树，要做n-1次加法，会产生n-1个新结点，组成一个2n-1的树。构造思路就是每次取两个权重最小的，以他们为左右孩子，生成父亲节点，权重等于二者之和。然后用这个节点与其他结点继续构造。
**一定要掌握手算构造哈夫曼树的方法**
哈夫曼树构建好后，规定从根开始，往右编1，往左编0. 编好之后还得会算平均编码长度，就用长度乘出现概率即可。

#### 哈夫曼树的实现
电脑生成哈夫曼编码是用静态链表实现的。这是静态链表的一个应用。  
具体怎么实现的就别管了。  [想看代码点这里](/tree1/huffmantree.h)

## 5. 一般树的存储结构、树和森林的转换
对于一般的树，也就是说不是二叉树，那么树的结点个数不一定，就要再讨论存储结构。  
树的四种遍历：先根遍历：先根，子树从左到右。  中根：先最左子树，再根，再遍历剩余子树。  后根：先所有子树，最后根。   层次：每一层从左向右遍历(利用队列实现)。
### 树的存储结构
#### 1) 树的双亲表示法
思想：对于一个节点，我们要能够记录他的双亲结点。因此从1开始给树结点编号，第i号结点对应数组中下标i的位置。数组要记录该结点的双亲结点是几号。例如，`A[i]`存储i号结点的双亲结点。  
特点分析： 对于一个节点，容易找到他的双亲，但是不容易找到他的孩子。

#### 2) 树的孩子表示法
思想：对于一个节点，我们要便于找到它的的孩子。 采用邻接表的方式完成。树的每个结点都配一个链表，整个树表示为一个链表的数组，这就叫邻接表。  
具体的实现方式：树的每个结点存到数组里，每个结点都这样定义：数据域和链表域。链表单元又是这样定义：数据域为此孩子在数组中的坐标，指针域为指向下一个孩子，也就是此结点的右侧一个兄弟的链表单元。每一个结点，顺着链表可以访问到孩子的坐标，拿着这个坐标再到树的数组找，就可以找到孩子结点。  
特点分析： 对于一个节点，容易找到他的孩子，不容易找到他的双亲结点。

#### 3) 树的孩子兄弟表示法
思想：树不好存储，但是二叉树好存储。如果任意一棵树有办法按照一种规则，转换成二叉树，那存储这棵树的问题就转换成了存储二叉树，就容易了。
实现方式：树的孩子兄弟表示法就是对于一个节点，让它的左侧第一个孩子当左边的孩子，让他同双亲的第一个兄弟当右孩子，就成了二叉树中的结点。**左孩子右兄弟**  
这个可以用静态链表实现

#### 4) 森林与二叉树转换
森林与二叉树转换其实是树的孩子兄弟表示法的延申。森林的几棵树的树根认为互为兄弟，就可以存成二叉树了。

**重点：树、森林、二叉树转换的遍历顺序关系**  
记忆这个表格

| 树 |森林|对应的二叉树|
|----|----|----|
|先序遍历|先序遍历|先序遍历|
|后序遍历|中序遍历|中序遍历|


## 6. 堆
堆是一种特殊的完全二叉树。它的特点是根和孩子有着固定的大小关系。如果每个结点都大于他的两个孩子结点，叫做大顶堆(根肯定是最大的)，如果每个结点都大于他的两个孩子结点，叫做小顶堆。
#### 堆的存储
堆其实上是顺序存储结构。由于堆是完全二叉树，所以可以利用性质5存储。给节点编号，每一个结点编号比如为i，则2i找到左孩子，2i＋1找到右孩子，`i/2`找到双亲结点。    
堆在我们画起来看是一个树形结构，其实在计算机里面存储就是一个数组。是我们规定的特殊操作方式让他成为一颗树。  
存储一个堆，其实就是一个顺序表，我们得有一个数组来存每个结点元素，再有一个整型变量告诉我们堆里面有几个元素。
```c
typedef struct heap{
    int data[Max_size];     //Max_size是宏定义的一个最大值
    int last;               //last表示堆的最后一个元素在data数组中的下标，也表示着整个堆的结点个数。
}Heap;
```

#### 堆的操作规则
堆的插入操作：先把新节点放在顺序存储的最后位置，然后不断和双亲比较，修正他的位置(上浮)。  
下面的代码以大顶堆为例子
```c
void Insert(Heap * heap, int value){
    heap->data[++heap->last] = value;    //第一步，先把新结点放在顺序存储最后位置。做两件事：首先last加1，因为有了新结点插进来。第二，把value放到last位置。
    int i = last;
    while(i != 1 && heap->data[i] > heap->data[i/2]){          //第二步，不断和双亲结点比较，如果位置不对就交换，使其上浮
        swap(&heap->data[i],&heap->data[i/2]);    
        i = i / 2;
    }                                
}
```
下面的代码以小顶堆为例子，优化了一下
```c
void Insert(Heap * heap, int value){
    heap->last++;    //第一步，last先加，但是不急着把value插进去
    int i = heap->last;
    while(i != 1 && heap->data[i] < heap->data[i/2]){          //第二步，不断和双亲结点比较，如果位置不对就交换，使其上浮
        heap->data[i] = heap->data[i/2];
        i = i / 2;
    }  
    heap->data[i] = value;
}

堆的根删除：堆如果要删除只可以删根节点。方法是把最后一个元素和根的位置交换，把根删掉,然后再给这个新的根节点找到正确的位置。  
下面代码是大顶堆删除根
```c
int deleteroot(Heap * heap){
    //第一步，先把根节点放到最后，最后节点拿到根位置，然后通过last-- 来表示原来的根不在堆里了
    int deleted = heap->data[1];   //被删的根先存起来，待会返回
    swap(heap->data[1] , heap->data[heap->last--])   //最后一个元素放到根位置后，last--
    int i = 1;
    while(2*i <= heap->last){
        int currentchild = 2*i;
        if(currentchild < heap->last && heap->data[currentchild] < heap->data[currentchild + 1] ){
            currentchild = currentchild + 1;             //这个条件语句后currentchild会调整为两个孩子中大的那个
        }
        if(heap->data[i] > heap->data[currentchild]){
            break;        //这个条件语句是判断已经找到了正确的位置
        }
        else{
            swap(&heap->data[i], &heap->data[currentchild]);     //若不在正确位置，则和大的那个孩子交换位置
            i = currentchild;                                 
        }
    }
    return deleted;        //返回被删除的原根节点 
}
```
下面代码是小顶堆删除根，循环内换了种写法，这一个写法思路比上面那个清晰
```c
int deleteroot(Heap * heap){
    //第一步，先把根节点放到最后，最后节点拿到根位置，然后通过last-- 来表示原来的根不在堆里了
    int deleted = heap->data[1];   //被删的根先存起来，待会返回
    swap(heap->data[1] , heap->data[heap->last--])   //最后一个元素放到根位置后，last--
    int i = 1;
    while(i <= last / 2){
        if(i * 2 == last ){
            if(heap->data[i] > heap->data[last]){
                swap(&heap->data[i] , &heap->data[last]);
                i = i * 2;    //即i = last，下一次循环就不会进入了
            }
        }
        else if(heap->data[2*i] > heap->data[2*i+1] && heap->data[i] > heap->data[2*i+1]){
            swap(&heap->data[i], &heap->data[2*i+1]);
            i = 2 * i + 1;
        }
        else if(heap->data[2*i] < heap->data[2*i+1] && heap->data[i] > heap->data[2*i]){
            swap(&heap->data[i], &heap->data[2*i]);
            i = 2 * i;
        }
     }
     else{
        i = last;    //上面几种情况样都不发生，说明此时结点i处在的就是正确的位置，只需退出循环
     }
     return deleted;
}
```
总之，堆这两个操作从人工来做是很简单的，我们直接对着图形化的堆进行操作，如果插入就插在最后结点然后向上修正位置，如果删除就把最后一个和根节点交换然后从上往下修正新根的位置。比如作业题。
> (a)Draw the binary min heap that results from inserting 8, 7, 3, 2, 4, 6, 9, 5, 1 in that order into an initially empty binary min heap. You do not need to show the array representation of the heap. You are only required to show the final tree.
> (b)Draw the result of one deletemin call on your heap drawn at the end of part (a).
做这道题，按顺序把九个数字插入空小顶堆中。我们画这个树就每次新结点画在完全二叉树的最后结点，然后和双亲结点比较看是否需要调换就行了。删除的时候，每次和左孩子、右孩子比较，和更大的那个孩子交换。
### 堆排序
堆排序的算法从逻辑上讲，经历了排完全二叉树、整理成堆、反复删除堆顶的过程，从存储空间上来看，始终是一系列操作发生在一个一维顺序表上。我们先根据上面实现好的堆来想如何堆排序。一个堆按顺序表上的顺序看是个无序序列。但是把它弄成有序特别容易：因为堆顶永远是最大或最小元素，而删除堆顶后他会出现在顺序表最后。那我们反复删除直到把堆删空，最大元素就依次从后往前排列成了有序序列。唯一没有解决的就是建堆的问题。因为堆排序的堆不是从空堆开始建，而是拿到一个无序数组，数都在里面了，让我们把他弄成堆，再反复删除。  
##### 排序问题
一个无序的数组，通过堆的算法弄成有序。
##### 问题分析
无序的数组拿到手上，其实是一颗完全二叉树(性质5).我们要设法把完全二叉树先整理，使它具有堆的性质。  
要利用堆的递归性质(树本身就是递归来的),一个堆中任意一个结点为根，都是一个堆。每个叶子都是一个堆。如果一个完全二叉树，只有根结点不满足堆的性质，那我们上面的代码已经能够把它弄出堆的性质了.刚才的删除算法，当根结点与最后结点交换之后，只有根节点破坏了堆的性质。 通过从根开始往下检查下沉到合适的位置，整个就又成为了堆。   
而一个任意的完全二叉树，他们的每个叶子结点都是堆。因此，把每个叶子加上它的双亲，就成为了只有根结点不满足堆的性质的情况。整理完它，再往上纳入一个结点，再下沉整理...这样堆的范围就逐渐的扩大，直到整个完全二叉树都变成了堆，建堆就完成了。
##### 总结
从一个无序数组，即完全二叉树整理成堆，通过从叶子节点开始向上整理扩大堆的方式。
##### 核心算法
我们需要的算法仅仅是在一个只有根结点破坏了堆性质的完全二叉树中，把根结点逐渐检查下沉到正确位置的算法，这正是刚才删除根结点的`while`循环部分。我们把它归纳成一个函数叫做 `pushdown`.  
`pushdown`我们希望它读入一个数组，这个数组里面其实是一个只有根结点破坏了堆性质的完全二叉树，然后指明其根节点和最后一个结点的坐标(这句话不准确，下面还有解释)，我们帮他整理成堆。
```c
void pushdown(int * arrey, int root, int last){
    int i = root;
    while(i <= last / 2){
        if(i * 2 == last ){
            if(arrey[i] > arrey[last]){
                swap(&arrey[i] , &arrey[last]);
                i = i * 2;    //即i = last，下一次循环就不会进入了
            }
        }
        else if(arrey[2*i] >= arrey[2*i+1] && arrey[i] > arrey[2*i+1]){
            swap(&arrey[i], &arrey[2*i+1]);
            i = 2 * i + 1;
        }
        else if(arrey[2*i] < arrey[2*i+1] && arrey[i] > arrey[2*i]){
            swap(&arrey[i], &arrey[2*i]);
            i = 2 * i;
        }
     }
     else{
        i = last;    //上面几种情况样都不发生，说明此时结点i处在的就是正确的位置，只需退出循环
     }
}
```
注意到，这个pushdown所作用的对象除了根结点以外要完全满足堆的性质，可我们处理的完全二叉树是完全没有堆性质的，如何用这个pushdown建立堆呢？关键在于我们如何调用它。  
再者，这里的pushdown和上面的删除算法有个区别，它所作用的对象本身其实是一个数组，只能说他运行中涉及到的片段满足完全二叉树的属性，但是`root`到`last`这个范围根本不一定是个完全二叉树，只能说是个数组片段。循环条件` while(i <= last / 2)`控制了循环结束时不会超出大树arrey的`last`结点，但对于`root`为根向下管辖的树而言，其最后一个结点很可能达不到`last`。   
准确的形容pushdown,是读入数组`arrey`和`root`,`last`三个参数，arrey是大树，last是大树arrey的最后结点号。而root是arrey中某个结点。作用就是在arrey中，以root为根的子树整理成堆。其中要求root的左子树右子树都已经是堆。 
> 因为root是在arrey中的子树，所以结点i下沉的过程中不会超过last。 一旦` i > last / 2 `就全是叶子节点了，循环怎么都该结束。

#### 堆排序的实现
##### 初始建堆
从叶子结点开始，逐层向上扩大堆。每个叶子都是堆了，所以pushdown的第一次作用从i = last/2这个节点开始。此后不断向i递减去做这件事情，直到1号结点做完，就建好堆。
##### 排序（一直删根）
一直删根，逐渐缩小堆的规模，每次当前最小（最大）元素将出现在当前堆的最后位置。随着堆规模缩小，有序部分逐渐增多。当堆删光的时候，就剩有序部分。
```c
void heapsort(int * arrey, int n){
    for(int i = n/2; i >= 1; i--){
        pushdown(arrey, i, n);
    }
    for(i = n; i >= 2; i--){
        swap(&arrey[1], &arrey[i]);                      
        pushdown(arrey, 1, i-1);          //这是个“散装”的deleteroot函数,第一句交换根和最后结点，第二句相当于last--然后把新根放到正确位置
    }
}
```
#### 重要算法：优先级队列
优先级队列其实是个堆，它的进队列就是堆的插入操作，它的出队列就是堆顶的删除操作。因为堆顶元素有某种最优先级别，所以总是堆顶元素出队列，所以是优先级队列。  
 ##### 典型问题
十万个数，以最快的速度找到最大的十个数字。  
解决方法：用优先级队列算法。前十个数建成一个小顶堆，此后凡是比堆顶小的数就略过，凡是比堆顶大的数就删除堆顶，把这个数插入到堆中。一旦遍历完一次，留在堆里面的就是最大的十个数字。
> 优先级队列就是通过堆设置了某种优先级，堆顶元素拥有最优先级总是出队列。这个算法就是 每次把手中最小的扔掉，换成一个更大的进来。
### 复杂度分析
凡是和堆有关的，涉及的循环中操作以 i = i * 2、i = i / 2这一类操作的复杂度是O( $\log_2n$),所以上面那个pushdown是O( $\log_2n$)，堆排序是O( $n\log_2n$)

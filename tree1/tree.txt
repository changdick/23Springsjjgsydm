树的基本概念
1、抽象定义：树这种结构的定义在于递归性，一个元素的后继互不相交的几部分，且每一个部分都是树
2、树高(深度)：有一个节点的树，树高为1，有两个节点的树，树高为2。以根节点为第一层，往下数有几层，树高就为几。

二叉树 Binary Tree

完全二叉树：向左对齐的，一层没满不能起下一层，没有左孩子不能有右孩子

**二叉树的五个性质
1、第i层结点个数最多为 2的i-1次方个
2、树高为k的二叉树结点数最多为 2的k次方-1个

//性质1、2是二叉树的结点计数性质

3、对任意的非空二叉树 T ，如果叶结点的个数为 n0，而其度为 2 的结点数为 n2，则：n0 = n2 + 1。

//性质3是二叉树结点关系，(二叉树的度只算出度不算入度)，叶子节点比二度结点多1。
//记忆： 以高k的满二叉树为例，叶子全在第k层有 2的k-1次方 个，
//而前面所有2度结点是高k-1的子树，结点数 2的k-1次方 - 1 个，刚好比叶子少1个

4、具有 n 个结点的完全二叉树的深度为 └log2n┘+ 1
// 结点数取log2，整的上界就是  这个公式更好
//性质4是完全二叉树的深度公式，已知完全二叉树的结点数可以求深度。
//记住求法：设树高为k，那么k-1层必满，k层可以满可以不满
//所以n的大小必大于高k-1层的满二叉树结点数，小于等于高为k的满二叉树的结点数
//然后对此式子变形， 得到层数k介于log n 和 logn + 1 之间，就是log n 向下取整加1 。

5、完全二叉树的结点序号性质：以根节点为1号，接下来从左向右有序编号，那么有以下性质：
    1)结点i如果有左孩子一定是 2i 号， 如果有右孩子一定是 2i + 1 号
    2)结点j如果要找他的双亲，双亲编号一定是 j / 2   (c语言int计算是这样，意思就是整数除 j//2)

//性质5是完全二叉树的结点序号性质， 这个性质表明完全二叉树可以成为线性结构，因为对i结点
//我们知道它的孩子节点和双亲结点各是多少

二叉树的遍历：二叉树的递归性，三种遍历顺序，可以用递归函数解决，递归函数是用了系统栈，就很简单
     比如中根遍历： 遍历(树){ 调用遍历函数遍历左子树;访问根;调用遍历函数遍历右子树 } 自然就完成了

二叉树的非递归遍历： 如果不用递归，不用系统栈，自己实现一个栈来遍历二叉树，难度比较大，是重点

如果已经把栈实现好，该如何处理这个树呢？
比如实现先序遍历，循环里的操作：
    1、我们是需要一个currenttree，是我们现在所在操作的结点，这样我们才能做输出、访问
    //注：currnttree 其实是一个结点，但从命名可以看出我们仍然是用了树结构的递归性，它的意义是它为根的整个子树
    2.1、如果currenttree非空，(我们要做的是：输出根，然后输出左子树，输出右子树),那么我们现在就输出他
    2.2、我们已经把currenttree输出了，(现在要输出左子树，待会还要回来找右子树，所以用到栈)，把currenttree进栈
    2.3、currenttree已经在栈里面，所以我们现在需要到左子树，也就是让currenttree的左孩子成为新的currenttree
    3.1、如果currenttree为空，则说明该子树遍历直接完成(那么现在就要去右孩子了,上一轮循环的那个双亲结点就在栈顶)退栈成为currenttree
    3.2、currenttree刚才输出过了，并且现在回到他，左孩子已经遍历过了，就让右孩子成为currenttree
    当以上循环操作设计好后，我们检验一下，发现树的先根遍历已经实现了。

比如实现中序遍历，循环里的操作：
    1.1、如果拿到的currenttree非空，(先访问左子树才访问它，所以先不访问)，则进栈，其左子树成为新的currenttree
    2.1、如果拿到的currenttree为空，(说明这个子树访问完毕,该访问根),退栈成为currenttree
    2.2、刚刚访问了currenttree的左子树，currenttree这个根节点现在可以进行访问
    2.3、(访问了根，现在访问右节点)直接让右孩子(右子树)成为currenttree 进入下一轮循环，实现完毕

    直接看会觉得，2.3后遍历操作突然就实现了，有点突然。其实非递归函数遍历也是抓住了树结构本身的递归特性
    我们命名的currenttree当前访问树，从逐行代码看，currenttree就是一个结点；但抽象看大的结构，currenttree就是树
    比如指定左子树currenttree后进入下一轮循环，我们根本不管下一轮循环它里面到底干什么了，我们要相信一个abstraction就是这一个循环将完成左子树的遍历
    而我们中根遍历，我们先访问左子树就记不住根了，所以根要用栈来记
    左子树遍历完了当然要退栈访问根，访问根完了当然要遍历右子树，我们让右孩子成为currenttree就是说右子树是currenttree，相信接下来会完成右子树的遍历
    而我们遍历右子树，要记住根吗？不用记住，我们currenttree从根到右子树，根访问完了，我们就不需要他了。
    而currenttree为空，找到空节点既是访问完了一个子树，同时我们看看这个所谓currenttree是谁的子树，多大的子树？实际上足够抽象的话，我们要这样想：
    栈顶是哪个节点，我们这个 currenttree == NULL 就是哪个节点的左子树访问完了的意思。

    理解这一块非递归函数遍历，不应该死扣具体几个结点的走向，而是要宏观抽象看，非递归是说不用递归函数，不是说没有递归性
    我们在循环里做的一直是“访问左子树，访问根，访问右子树”“访问根，访问左子树，访问右子树”
    理解完后我们再写一遍思路：
        中序遍历
        循环里{
            //此刻我们手握currenttree
            若currenttree非空：  //去遍历他的左子树，此前进栈留存
                Push(&Stack,currenttree);
                currenttree = currenttree->leftchild；
            若currenttree为空：    //说明currenttree遍历完成，可以回去找根  //找以currenttree作为左子树的根，currenttree可能很大一个树，可能是空树
                //currenttree的双亲此刻在栈顶,而且currenttree是左子树
                currenttree = Pop(&stack);
                访问currenttree；
                currenttree = currenttree->rightchild;
                //我们指明currenttree，下一轮循环自然遍历了他。
            }
        循环条件是在树为空且栈为空时结束

第四种遍历是二叉树的层次遍历。层次遍历借助队列来实现，算法简单就是，根节点进队列，此后循环，每次出队列的同时做访问并让出队列的这个结点的左孩子、右孩子依次进队列。当队列空了就说明遍历完了。

二叉树的求深度操作就很简单了，利用递归性，只要把左右子树深度用递归求出，然后加上1（根节点）就行了。当树为空时，高度认为是0.

利用二叉树的前缀、中缀、后缀表达式确定二叉树。要确定一个二叉树，必须知道中序遍历，然后再知道前序遍历和后序遍历一种即可。

线索二叉树：可以证明，当二叉树以我们定义的那种两指针域形式，n个结点的二叉树会有n+1个空指针域没有被使用。线索二叉树就是充分利用了这些空指针域，让遍历等操作更好实现。
    一、线索二叉树的概念：线索二叉树的结点如果没有左孩子或没有右孩子，那么这个指针就指向它在前序遍历或中序遍历的前驱或后驱结点。
    在没有线索的时候，对于一个结点，如果它有右孩子，我们有办法找他的中序后继；如果他有左孩子，我们有办法找他的中序前驱。但如果没有的话，我们找不了。而线索就是在找不了的情况下直接帮我们指过去
    这就意味着：对于一个线索二叉树，我们肯定知道任意一个结点的中序后继，那么我们有办法简单地实现中序遍历。而且，我们肯定知道任意一个节点的中序前驱，意味着我们甚至可以倒着中序遍历。
    那么现在构建线索二叉树。比如构建中序线索二叉树。
    中序线索化的方法：
        需要掌握两个节点：当前访问结点和上一个访问的结点。加入要加入线索，肯定是在相继两个访问的之间加一个。其实无外乎：current是pre的后继。
        真添加起来其实是两种：pre的后继是current，current的前驱是pre。用递归算法不难的。
    线索二叉树的构成：
        结点定义：五个域，多了两个tag域指示指针指向的是孩子还是线索。
        此外，增加了一个头结点，中序遍历首元的前驱认为是头结点，中序末元的后继认为是头结点。头结点左孩子有且是真树根，头结点右孩子有且是他自己。
        待会会解释到：头结点右孩子有且是头结点自身是非常妙的设计，这是有利于遍历的。
        因为Innext（）帮我们找到中序后继：如果有右孩子，中序后继就是右子树最左叶子；如果没有右孩子，线索告诉我们谁是中序后继。
        利用innext函数告诉我们中序后继，那么我们持续访问后继，就完成了中序遍历。
        而 头结点右孩子是头结点自己 这个规定，使得右子树最最左叶子刚刚好找到中序首元素，就是整棵树的最左叶子。

    线索二叉树的中序线索化：
        先初始化二叉树，给一个基础的二叉树加上头结点，并把头结点的各项设置好。
        头结点为pre，树根也就是pre的左孩子为current
        此后调用递归函数Intreading，我们定义的这个函数是参数为两个结点指针，返回pre，为了更新pre（书上我也不知道怎么做到的）
        intreading的内容：(current非空时做下面的事，current为空什么都不做就返回pre就完了)
            先递归调用，线索化左子树
            对这两个结点做线索化：如果current没有左子树，左孩子就是pre；如果pre没有右子树，右孩子就是current，并且tag记得要调
            再递归调用，线索化右子树(传入的pre更新为current)
        注：这里面的递归中，利用递归函数自己的返回值保持对pre的更新；
        (intreading的最后调用是中序最后一元素为pre，其右子树为current，然后就退出了调用,只剩pre
        的右孩子尚未设置)
        再补充让此时的pre，也就是中序最后一个元素，也就是整棵树的最右叶子，它的右孩子线索到头结点
        至此，一个线索二叉树就完整地创建好了！！

    线索二叉树的中序遍历：
        先引入中序后继函数innext（），因为我们的线索二叉树创建的巧妙，innext很简单可以返回中序后继
        只要从头结点开始，每次访问后继，回到头结点时中序遍历就完了。

    线索二叉树插结点的线索修正：
        其实广义的说，中序遍历里，右子树就是中序后继集(但是他们也要按中序后缀形式来写开)，左子树就是中序前驱集、
        广义地说，一个树是其他节点的左子树，那这个节点就是他的后继；一个树是其他节点的右子树，那这个节点就是他的前驱
        比如把R插入S的右孩子位置，不管S本来有没有右孩子，我们知道以下事实：
            R要继承S的后继         ——  R的右孩子、右孩子tag与S一样
            R要当S的后继            ——  S的右孩子是R
            R肯定没有左孩子，S是其前驱   ——  R的左孩子是线索到S
        这三个肯定是固定操作，然后现在在于，S如果本来有孩子的话，S的中序后继即他的右子树最左叶子会线索一条到S
        这个后继已经被R继承了，所以直接调用Innext（R）找到这个结点，把他的终须前驱改到R，那么就全部做完了。


二叉树的复制：
    二叉树等价：基础：两个空树就是等价的  其他：先比根，再比左子树相同，在比右子树相同（递归调用） 都相同判断等价
    二叉树复制算法： 也是递归， 基础情况：空树复制出来就是空树。 其他：根一样，左子树复制其左子树，右子树复制其右子树

表达式的表示：
    二叉树可以应用于表达式前中后缀的转换，比如说一个存好的表达式二叉树，把它用中缀表示打印出来，而且要按照运算顺序加好括号，要怎么做呢
    对于存好的二叉树要输出中缀表达式，直接中缀遍历输出即可，同时做一下修改让它加括号。{每次遍历,若当前树非叶子，先加括号在遍历左子树，
    接着直接输出根节点，遍历右子树，遍历完再加括号。}

堆(heap):
    堆是一种特殊的完全二叉树，它的特点是根和孩子的大小关系固定，可以分大顶堆和小顶堆，大顶堆就是每一个结点都比他的孩子来的大，小顶堆每一个节点比孩子小。
    由于堆是完全二叉树，完全二叉树就可以用顺序存储实现，每一个结点编号比如为i，2i找到左孩子，2i＋1找到右孩子，i//2找到双亲结点。
    堆的插入算法：先把新节点放在顺序存储的最后位置，然后不断和双亲比较，修正他的位置（上浮）
    堆的根删除：堆如果要删除只可以删根节点。方法是把根往下沉到最底，每次选择的两个孩子中适合继承他位置的来交换位置。

树：
    上面搞了二叉树，二叉树由于孩子数量固定，可以定义明确的数据类型和存储方式，完全二叉树还可以采用顺序存储。
    但是一棵没规律的树就不好存储。
    一般树的遍历原理：先序遍历：先根，然后自左向右遍历子树。  中序遍历：先最左子树，再根，然后自左向右遍历其他子树。  后序遍历：自左向右遍历全部子树，最后访问根
    层次遍历：利用队列，根进队列，此后每次出队列同时访问该结点并让孩子自左向右依次进队列，不断循环，直至队列空

    由于一般的树不好存储，所以要讨论存储方式。
树的存储结构：
    1、树的双亲表示法
        是一种顺序存储结构，在一个线性表中，每一点由两块组成：结点数据域和双亲位置域。
        对一棵树，按照层次遍历的顺序从1开始编号。每一个节点都有对应号码i，就储存在下标i的格子里。
        根是[1]位置元素，[0]位置不用。
        每个节点的parent域是其双亲的编号。
        这样的好处：拿到一个结点，我们知道他的双亲是谁；拿到一个结点，我们可以知道他的最左孩子是谁。
        缺点：拿到一个结点，想要找到它所有的孩子不容易。因为我们从这一点n起往下顺序找，找到第一个parent==n的就是最左孩子，但是右边还有多少个不容易表示。
    2、树的孩子表示法
        树的每个结点存到数组里，每个结点都这样定义：数据域和链表域。链表单元又是这样定义：数据域为此孩子在数组中的坐标，指针域为指向下一个孩子，也就是此结点的右侧一个兄弟的链表单元。
        每一个结点，顺着链表可以访问到孩子的坐标，拿着这个坐标再到树的数组找，就可以找到孩子结点。
    3、树的孩子兄弟表示法
        树我们不好存，但是我们已经有办法储存二叉树了。如果任意一棵树有办法转换成二叉树，那存二叉树就好了。
        按此思想，树的孩子兄弟表示法就是对于一个节点，让它的左侧第一个孩子当左边的孩子，让他同双亲的第一个兄弟当右孩子，就成了二叉树中的结点。
        左孩子，右兄弟
    4、森林与二叉树转换
        我们可以把树变成二叉树，森林变成二叉树的方法是一样的。把森林的几棵树的树根认为互为兄弟，就可以存成二叉树了。

        转换后的遍历关系：
        有一个表
        树              森林              二叉树
        先序            先序               先序
        后序             中序               中序

        树的一个性质：有几棵树，节点就比边多几。树就是特殊情况n = 1


哈夫曼树
    二叉树、扩充二叉树、带权路径等概念引入哈夫曼树
    简而言之，这样一个二叉树，结点是奇数个，叶子比二度结点多1个，没有1度结点，并且所有叶子带权值，表示一个跟到这里一个路径的权重。
    这样加权路径长就有意义，研究整个树的带权路径长什么时候最小是很有价值的。带权路径长最小的树就是哈夫曼树

    思考：如果我们想让带权路径长最小，我们希望权重大的点路径尽可能小，权重小的点我们可以容忍它路径比较长。
    构造：拿到n个结点，每次取两个加出一个新的。 n个点构造哈夫曼树，要做n-1次加法，会产生n-1个新结点，组成一个2n-1的树。
    这里关联到树的性质：首先，二叉树的性质3： 叶子比二度结点多1. 这边很显然，因为n个节点构造哈夫曼树的过程做了n-1次加法，生成新结点肯定全是2度
            还一个性质就是二叉树如果由m个结点，空指针域m+1个（带两个指针域的定义方式），去掉所有带权叶子，这个树就剩n-1个结点，空指针域刚好让我们把所有n个叶子填进去
    具体的构造思路就是每次取两个权重最小的，以他们为左右孩子，生成父亲节点，权重等于二者之和。然后用这个节点与其他结点继续构造。

    哈夫曼树的特点：权值最小的路径最长，权值最大的离根最近。不存在1度结点。

    Huffman编码：如果出现的概率有一个权重，就构造哈夫曼树，规定往左0，往右1，把信息转化成01的前缀码。

    哈夫曼树用静态链表来实现，huffmantree.h里面有代码
    思想：用selectmin()帮我们从已经有的节点中选出两个最小的，以他们为孩子构造新结点，调整好连接，循环往复至结束

二叉排序树（二叉搜索树）：
    二叉树的结点满足左<根<右，这样的树在存储要排序搜索的数据效率更高，树为平衡时查找效率O(log n)

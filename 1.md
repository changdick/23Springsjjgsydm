# 第一章 线性结构  

## 考点  
- 顺序存储结构、链式存储结构、线性表的操作、栈、队列和数组(矩阵的压缩存储)
- 涉及的算法比如头插法(链表倒序), 快慢指针法(处理链表的一些操作用到)、栈的应用中表达式求值
- 静态链表(静态链表在后面Huffman树、树的存储，拓扑排序都涉及)

  
## 1.线性表的顺序存储
使用线性表来储存的数据，在逻辑上是有线性的关系，所以在计算机中储存的数据结构也是线性的。按顺序来排列，比如数组，就给我们一个线性结构的示例。  
**顺序结构**： 顺序结构是在内存空间上，就是连续的内存空间。比如一串数据有固定顺序，那么在连续内存中按顺序存放，这就是顺序结构的一个线性表。
数组就是连续内存空间上的线性表实现。通过数组可以实现对这段连续内存空间的随机访问。数组的本质就是连续内存空间，顺序存储结构其实就是连续内存空间的使用。  
>注：这是C语言中关于数组的一个现象。已知数组a，a[5] 和 5[a] 得到的值是一样的。这是为什么呢？（StackOverflow上一个问题和回答） 
> The C standard defines the `[]` operator as follows:
> `a[b] == *(a + b)` 
> Therefore` a[5] `will evaluate to: `*(a + 5)`  and `5[a]` will evaluate to:  `*(5 + a)`. 
> `a` is a pointer to the first element of the array. `a[5]` is the value that's 5 elements further from a, 
> which is the same as `*(a + 5)`, and from elementary school math we know those are equal

这个揭示了数组调用是连续内存访问的原理，所以线性表的顺序结构，其实就是物理上在内存中是连续的一块空间，我们知道开始那块的地址（基地址），
就可以按顺序存储元素，随机访问第i个。  
实现线性表的顺序存储结构简单，一个最简单的顺序表，我们只需要建一个数组来操纵，并且我们得知道表长有多长(因为数组自己不会告诉我们元素个数)，因此我们
还需要一个表长的变量。

```
int data[MAX_length];
int length;         
```
就这样两行，我们其实就做出了一个顺序表，可以按顺序存放元素，访问某个元素，并且告诉我们表里有多少个元素。但是他作为顺序表，一个数据结构，自己是一个型，我们还要给它
包装起来，让他自己作为一个型存在而不是两个分散的指针和整型，方便我们调用，和我们待会要定义的操作对接。所以我们要包装一下。
```
Typedef struct{
    int data[Max_length];       //这个是数组，有一个最大表长度Max_length
    int length;     //作为表长，我们在初始化的时候可以让他为元素个数，也可以让他为最后一个元素的下标（元素个数-1）
}SList;            //SList 是我们给这种顺序表取的类型名
```
然后我们就拿着`SList`这个类型，申请内存空间，就可以说是创造出了一个SList型顺序表了。然后就定义一些它的操作。

我们要建表，要初始化吧length调成0(刚开始是个空表，长度当然是0)  就做一个函数`SList * Initlist()` 可以返回一个空表  
我们要插入元素，就搞一个函数 `void Insert(SList * list, int value, int index)`
  >在顺序的线性表插入元素value到index位置，我们直接写注释说明它完成的功能，顺序表插入元素实际上是把index位置起的每一个元素往后移动一位，然后value放到
  >index位置上去。同时多了一个元素，length相应要加一。至于具体代码怎么实现的我们就别管了。

我们要删除元素，就搞一个函数 `int delete(SList* list, int index)`
> 把顺序表第index个元素给删掉，并且返回他。也可以不用返回值，而是送变量地址进去接收的方式来实现返回。具体顺序表中实现这个删除的话是把index后面所有元素依次往前
> 移动，并且length要相应减一。 至于具体代码怎么实现的我们就别管了。

我们要修改某元素，就搞一个函数 `void change(SList * list, int index, int value)`
> 这个元素把原来index位置元素改成value。  实现是非常简单的，直接一句 `list.data[index] = value;` 好像就完成了，不过我们不关心函数怎么完成它的功能的，
> 我们只在乎函数能帮我们完成什么操作，不管他怎么做到的。

我们要按顺序遍历顺序表，就搞一个函数 `void travle(SList* list)`
>这个函数实现对顺序表list的遍历。遍历顺序表其实就依次访问。我们干脆把他实现一下，我们就依次打印出来元素，就算是遍历了。
>```
>void travle(SList* list){
>     //注意下面的循环范围，当length定义是表示表的元素个数，并且表从坐标0开始存储，那么最后一个元素的坐标是length-1，所以这样写
>     for(i = 0; i < length; i++){
>         printf(" %d", list.data[i]);
>     }
>}     
>```
>强调，我们根本不在乎他怎么实现的。我们只在乎遍历这个操作。函数怎么帮我们遍历就别管了。

我们要查找顺序表中的某一个元素，就搞一个函数 `int search(SList* list, int target)`
> 在list中按查找是否有target存在。如果有就返回1，没有返回0. 其操作就是从头依次按顺序比对，比对到了返回1，全比完没有就返回0.  
> 我们要注意一件事情，那就是**平均查找长度**。后面查找章节也会涉及的ASL。 如果想知道ASL很简单，如果它在第一个，查找1次，第二个查找2次  …… 最后一个查找n次，
> 那么我们的比较次数就`(1+2+···+n) / n` 就完了，应该是 `(n+1) / 2` ，这就推出了所谓O(n)的时间复杂度。


**重点：根据我们上面对操作的具体实现过程的分析，我们发现，顺序结构的访问是随机访问，访问瞬间完成，而删除、插入操作每次都需要移动后续每一个元素，耗时O(n)水平的。**

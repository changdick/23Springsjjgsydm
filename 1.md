# 第一章 线性结构  

## 考点  
- 顺序存储结构、链式存储结构、线性表的操作、栈、队列和数组(矩阵的压缩存储)
- 涉及的算法比如头插法(链表倒序), 快慢指针法(处理链表的一些操作用到)、栈的应用中表达式求值
- 静态链表(静态链表在后面Huffman树、树的存储，拓扑排序都涉及)

  
## 1. 线性表的顺序存储
使用线性表来储存的数据，在逻辑上是有线性的关系，所以在计算机中储存的数据结构也是线性的。按顺序来排列，比如数组，就给我们一个线性结构的示例。  
**顺序结构**： 顺序结构是在内存空间上，就是连续的内存空间。比如一串数据有固定顺序，那么在连续内存中按顺序存放，这就是顺序结构的一个线性表。
数组就是连续内存空间上的线性表实现。通过数组可以实现对这段连续内存空间的随机访问。数组的本质就是连续内存空间，顺序存储结构其实就是连续内存空间的使用。  
>注：这是C语言中关于数组的一个现象。已知数组a，a[5] 和 5[a] 得到的值是一样的。这是为什么呢？（StackOverflow上一个问题和回答） 
> The C standard defines the `[]` operator as follows:
> `a[b] == *(a + b)` 
> Therefore` a[5] `will evaluate to: `*(a + 5)`  and `5[a]` will evaluate to:  `*(5 + a)`. 
> `a` is a pointer to the first element of the array. `a[5]` is the value that's 5 elements further from a, 
> which is the same as `*(a + 5)`, and from elementary school math we know those are equal

这个揭示了数组调用是连续内存访问的原理，所以线性表的顺序结构，其实就是物理上在内存中是连续的一块空间，我们知道开始那块的地址（基地址），
就可以按顺序存储元素，随机访问第i个。  
实现线性表的顺序存储结构简单，一个最简单的顺序表，我们只需要建一个数组来操纵，并且我们得知道表长有多长(因为数组自己不会告诉我们元素个数)，因此我们
还需要一个表长的变量。

```
int data[MAX_length];   //这个MAX_length宏定义来的
int length;         
```
就这样两行，我们其实就做出了一个顺序表，可以按顺序存放元素，访问某个元素，并且告诉我们表里有多少个元素。但是他作为顺序表，一个数据结构，自己是一个型，我们还要给它
包装起来，让他自己作为一个型存在而不是两个分散的指针和整型，方便我们调用，和我们待会要定义的操作对接。所以我们要包装一下。
```
Typedef struct{
    int data[Max_length];       //这个是数组，有一个最大表长度Max_length
    int length;     //作为表长，我们在初始化的时候可以让他为元素个数，也可以让他为最后一个元素的下标（元素个数-1）
}SList;            //SList 是我们给这种顺序表取的类型名
```
然后我们就拿着`SList`这个类型，申请内存空间，就可以说是创造出了一个SList型顺序表了。然后就定义一些它的操作。

我们要建表，要初始化吧length调成0(刚开始是个空表，长度当然是0)  就做一个函数`SList * Initlist()` 可以返回一个空表  
我们要插入元素，就搞一个函数 `void Insert(SList * list, int value, int index)`
  >在顺序的线性表插入元素value到index位置，我们直接写注释说明它完成的功能，顺序表插入元素实际上是把index位置起的每一个元素往后移动一位，然后value放到
  >index位置上去。同时多了一个元素，length相应要加一。至于具体代码怎么实现的我们就别管了。

我们要删除元素，就搞一个函数 `int delete(SList* list, int index)`
> 把顺序表第index个元素给删掉，并且返回他。也可以不用返回值，而是送变量地址进去接收的方式来实现返回。具体顺序表中实现这个删除的话是把index后面所有元素依次往前
> 移动，并且length要相应减一。 至于具体代码怎么实现的我们就别管了。

我们要修改某元素，就搞一个函数 `void change(SList * list, int index, int value)`
> 这个元素把原来index位置元素改成value。  实现是非常简单的，直接一句 `list.data[index] = value;` 好像就完成了，不过我们不关心函数怎么完成它的功能的，
> 我们只在乎函数能帮我们完成什么操作，不管他怎么做到的。

我们要按顺序遍历顺序表，就搞一个函数 `void travle(SList* list)`
>这个函数实现对顺序表list的遍历。遍历顺序表其实就依次访问。我们干脆把他实现一下，我们就依次打印出来元素，就算是遍历了。
>```
>void travle(SList* list){
>     //注意下面的循环范围，当length定义是表示表的元素个数，并且表从坐标0开始存储，那么最后一个元素的坐标是length-1，所以这样写
>     for(i = 0; i < length; i++){
>         printf(" %d", list.data[i]);
>     }
>}     
>```
>强调，我们根本不在乎他怎么实现的。我们只在乎遍历这个操作。函数怎么帮我们遍历就别管了。

我们要查找顺序表中的某一个元素，就搞一个函数 `int search(SList* list, int target)`
> 在list中按查找是否有target存在。如果有就返回1，没有返回0. 其操作就是从头依次按顺序比对，比对到了返回1，全比完没有就返回0.  
> 我们要注意一件事情，那就是**平均查找长度**。后面查找章节也会涉及的ASL。 如果想知道ASL很简单，如果它在第一个，查找1次，第二个查找2次  …… 最后一个查找n次，
> 那么我们的比较次数就`(1+2+···+n) / n` 就完了，应该是 `(n+1) / 2` ，这就推出了所谓O(n)的时间复杂度。


**重点：根据我们上面对操作的具体实现过程的分析，我们发现，顺序结构的访问是随机访问，访问瞬间完成，而删除、插入操作每次都需要移动后续每一个元素，耗时O(n)水平的。**

### 算法：有序顺序表归并（放后面）

## 2. 线性表的链式存储结构
线性表的链式存储结构就是链表，链表在内存中是散的，物理位置上没有关系，但是每一个内存块间串起来，并且每一个块都知道下一个块的位置，因此可以依次向下按顺序访问。  
链表是按照单个单个的结点串起来的，而这样一条长链我们一般只知道一个在链头的指针，我们对链表的一切访问、操作都得通过这个头指针往下走，某种意义上，这个头指针可以说是链表的“名字”的存在，就像 `int a[3] = {5, 2, 0}` 后我们可以说这个数组是`a` 。  
链表是按结点或者存储单元来组织的，所以我们只需定义它单个结点的数据类型。先定义一下。
```
Typedef struct node{
    int data;             //这是数据域，数据类型不妨用int 
    struct node * next;   //这是指针域，指针域类型就是这个结点自己的类型，指向下一个
}Linkedlist;              //我们把它称作Linkedlist， 是考虑到它链表本身也是用Node型指针来表示的，命名这个根本不重要
```  
反正我们知道他是**数据域和指针域**就行了，数据域存数据，指针域指向下一个结点，当然最后一个节点指针域就是NULL了。

下面直接定义操作和解释大概原理，_至于代码实现我们就别管了。_  
我们要介绍操作，干脆先讲插入中的头部插入。假如已经有一条链表Linkedlist * list, list已经有不少结点了，现在要求我们把一个新结点插在链表头部，成为新的第一个结点。
为了做这件事，我们搞一个函数 `void Insertstart(Linkedlist* list, int value)`
> 这个函数能够建一个新的结点，储存值value，并插入到链表头。怎么实现先放一边，我们现在要这样想：  
> 链表是长什么样的？如果是每一个结点依次连接，头指针直接指第一个结点，那么我们把这个新结点插进去，头指针就指向了新结点，这就意味着：头指针改变了。头指针改变是件大事，这又牵扯到C语言函数传参的问题。我们用最俗的方式告诉你这里会出问题：刚才说头指针是链表的“名字”，你把人名字在函数里改成了别的，肯定会面临一些问题。
> >细说就是，函数`Insertstart`外面主函数里的头指针(假设变量名是head)`head`,和调用`Insertstart(head, 7)` 传到函数里 的head根本不是同一个head，而是一份拷贝
> >函数`Insertstart`里面的那个`head`指向了新的_第一个_结点(注意我的用词)，而函数外面主函数里的`head`根本没有改变。内存里面，新的结点7确实是插入到链表的头部去
> >并且成为了链表最开始的结点，但是主函数的head没有指向它，而是仍然指在原来的那个位置，也就是现在的第二个结点。而刚才传参拷贝的那份`head`的的的确确改指到新结点
> >“7”了，但是函数调用一结束它就没了，没有对外面也就是主函数内造成任何影响。这就导致，新结点接上去了，但是链表头指针没变，因此，我们头插的新结点仍然找不到。 
>  
> 上面说这些是为了引出头结点的概念。**从这里开始看**，总之，链表要有头结点，使得插入、删除等操作不必考虑头指针改变，任意位置操作都是统一的。  

带头结点链表：设置一个不储存值的结点，所有有意义的结点都接在它的后面，并且头指针指向它。这样，头指针永远不会有考虑改变的问题，所有的操作是统一的。

### 链表操作
链表的的插入、删除、修改，无外乎**找到位置，修改指针**。修改指针的过程就是注意，指针是我们访问一个结点的唯一途径，指针绝对不能丢  
比如说 A->B要把C结点插入到A，B中间，我们首先要找到A（所谓提前一个位置）,肯定是C先指向B(我们可以访问B，通过A可以访问B),然后A指向C。假如A先指向C，然后B就丢了。进行不下去了。所以操作过程中注意不能出现把访问的途径给搞没了，待会就访问不了的情况，一般就不会选错。

**重点：链表的特点是访问任何一个都得依次按顺序访问下来，不是随机访问，访问的代价是O(n). 而链表在插入、删除的时候不必移动大量元素，而是修改一下指针就完成了，时间复杂度也是O(n)** (两个结构优缺点分析)

### 重要算法：快慢指针法
快慢指针法用于一些链表的处理，意思就是出两个指针，一个走前一个走后，给四道例题看看。
1. 如何判断链表是否有环           两个指针一个每次走两步，一个每次走一步，如果有环的话，快的在环里肯定追上慢的
2. 如何找到链表的倒数第m个元素     两个指针从起点出发，一个先走m步，然后两个再同步调走，直到前面的到达了最后一个，后面的就在倒数第m个
3. 线性链表中间位置的元素         两个指针一个每次走两步，一个每次走一步，快的走完，慢的自然走到中间
4. 求两个单链表是否交叉           测出两个表的长度，长的和短的，长的那个先让指针走gap步（gap是表长之差），然后两指针同步调往下走，相等的时候就是交点

### 算法：链表倒序
链表倒序的核心是头插法，我最早想的头插法是逐一遍历原来链表，然后把每一个元素头插法插入一个新的链表，但这样子空间复杂度O(n),实际上O(1)就够了。  
做法：一个链表出来，我们就要用它已有的空间，把头指针直接当成一个新链表，开始头插法建表。具体的操作步骤如下：
```
一、把第一个元素的结点标为p，然后断掉头结点指向空。
二、将头结点看成一个新链表，p即后面所有结点看成原始的链表。    
三、开始如下循环：把原始链表中的每一个元素依次头插到新链表中即可。
```
**注意**；首先把第一个元素的结点标为p，否则断开头结点，使头结点成为新链表的时候，原来的链表就丢失了。其次，这一个过程想要实现p指的那边链表逐一头插到新链表里，实际的代码实现中还需要引入一个q指示下一个元素，否则p插走之后链表就丢了。 ppt里的代码和图片不清楚，其实上就是头插法。







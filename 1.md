# 第一章 线性结构  

## 考点  
- 顺序存储结构、链式存储结构、线性表的操作、栈、队列和数组(矩阵的压缩存储)
- 涉及的算法比如头插法(链表倒序), 快慢指针法(处理链表的一些操作用到)、栈的应用中表达式求值
- 静态链表(静态链表在后面Huffman树、树的存储，拓扑排序都涉及)

  
## 1. 线性表的顺序存储
使用线性表来储存的数据，在逻辑上是有线性的关系，所以在计算机中储存的数据结构也是线性的。按顺序来排列，比如数组，就给我们一个线性结构的示例。  
**顺序结构**： 顺序结构是在内存空间上，就是连续的内存空间。比如一串数据有固定顺序，那么在连续内存中按顺序存放，这就是顺序结构的一个线性表。
数组就是连续内存空间上的线性表实现。通过数组可以实现对这段连续内存空间的随机访问。数组的本质就是连续内存空间，顺序存储结构其实就是连续内存空间的使用。  
>注：这是C语言中关于数组的一个现象。已知数组a，a[5] 和 5[a] 得到的值是一样的。这是为什么呢？（StackOverflow上一个问题和回答） 
> The C standard defines the `[]` operator as follows:
> `a[b] == *(a + b)` 
> Therefore` a[5] `will evaluate to: `*(a + 5)`  and `5[a]` will evaluate to:  `*(5 + a)`. 
> `a` is a pointer to the first element of the array. `a[5]` is the value that's 5 elements further from a, 
> which is the same as `*(a + 5)`, and from elementary school math we know those are equal

这个揭示了数组调用是连续内存访问的原理，所以线性表的顺序结构，其实就是物理上在内存中是连续的一块空间，我们知道开始那块的地址（基地址），
就可以按顺序存储元素，随机访问第i个。  
实现线性表的顺序存储结构简单，一个最简单的顺序表，我们只需要建一个数组来操纵，并且我们得知道表长有多长(因为数组自己不会告诉我们元素个数)，因此我们
还需要一个表长的变量。

```c
int data[MAX_length];   //这个MAX_length宏定义来的
int length;         
```
就这样两行，我们其实就做出了一个顺序表，可以按顺序存放元素，访问某个元素，并且告诉我们表里有多少个元素。但是他作为顺序表，一个数据结构，自己是一个型，我们还要给它
包装起来，让他自己作为一个型存在而不是两个分散的指针和整型，方便我们调用，和我们待会要定义的操作对接。所以我们要包装一下。
```c
Typedef struct{
    int data[Max_length];       //这个是数组，有一个最大表长度Max_length
    int length;     //作为表长，我们在初始化的时候可以让他为元素个数，也可以让他为最后一个元素的下标（元素个数-1）
}SList;            //SList 是我们给这种顺序表取的类型名
```
然后我们就拿着`SList`这个类型，申请内存空间，就可以说是创造出了一个SList型顺序表了。然后就定义一些它的操作。

我们要建表，要初始化吧length调成0(刚开始是个空表，长度当然是0)  就做一个函数`SList * Initlist()` 可以返回一个空表  
我们要插入元素，就搞一个函数 `void Insert(SList * list, int value, int index)`
  >在顺序的线性表插入元素value到index位置，我们直接写注释说明它完成的功能，顺序表插入元素实际上是把index位置起的每一个元素往后移动一位，然后value放到
  >index位置上去。同时多了一个元素，length相应要加一。至于具体代码怎么实现的我们就别管了。

我们要删除元素，就搞一个函数 `int delete(SList* list, int index)`
> 把顺序表第index个元素给删掉，并且返回他。也可以不用返回值，而是送变量地址进去接收的方式来实现返回。具体顺序表中实现这个删除的话是把index后面所有元素依次往前
> 移动，并且length要相应减一。 至于具体代码怎么实现的我们就别管了。

我们要修改某元素，就搞一个函数 `void change(SList * list, int index, int value)`
> 这个元素把原来index位置元素改成value。  实现是非常简单的，直接一句 `list.data[index] = value;` 好像就完成了，不过我们不关心函数怎么完成它的功能的，
> 我们只在乎函数能帮我们完成什么操作，不管他怎么做到的。

我们要按顺序遍历顺序表，就搞一个函数 `void travle(SList* list)`
>这个函数实现对顺序表list的遍历。遍历顺序表其实就依次访问。我们干脆把他实现一下，我们就依次打印出来元素，就算是遍历了。
>```c
>void travle(SList* list){
>     //注意下面的循环范围，当length定义是表示表的元素个数，并且表从坐标0开始存储，那么最后一个元素的坐标是length-1，所以这样写
>     for(i = 0; i < length; i++){
>         printf(" %d", list.data[i]);
>     }
>}     
>```
>强调，我们根本不在乎他怎么实现的。我们只在乎遍历这个操作。函数怎么帮我们遍历就别管了。

我们要查找顺序表中的某一个元素，就搞一个函数 `int search(SList* list, int target)`
> 在list中按查找是否有target存在。如果有就返回1，没有返回0. 其操作就是从头依次按顺序比对，比对到了返回1，全比完没有就返回0.  
> 我们要注意一件事情，那就是**平均查找长度**。后面查找章节也会涉及的ASL。 如果想知道ASL很简单，如果它在第一个，查找1次，第二个查找2次  …… 最后一个查找n次，
> 那么我们的比较次数就`(1+2+···+n) / n` 就完了，应该是 `(n+1) / 2` ，这就推出了所谓O(n)的时间复杂度。


**重点：根据我们上面对操作的具体实现过程的分析，我们发现，顺序结构的访问是随机访问，访问瞬间完成，而删除、插入操作每次都需要移动后续每一个元素，耗时O(n)水平的。**

### 算法：有序顺序表归并
这个算法还是很重要的，有序顺序表的归并是后面归并排序的很重要一部分，归并排序反复做的事情就是把两个已经归并排序好的有序数列归并起来。  

有两个顺序表，类型都是上面的SList，分别是`lista` and `listb`, 他们已经按照从大到小的顺序排好了。现在已经有一个新的表`listc`，listc将是把`lista` and `listb`归并起来得到的，现在要我们实现这个归并算法，完成这个归并。
```c
void merge(SList * lista, SList * listb, Slist * listc){    //函数参数是三个表的指针，a和b是要归并的两个表，c是事先准备好要储存a和b的归并结果
    int* pa = lista->data; 
    int* pb = listb->data;    //这两行是用两个指针指向两个表的内存首地址，待会让这两个往下遍历来将a、b中元素逐一读进c中
    int* pc = listc->data;    //这一行是用一个指针指向c表的内存首地址，待会负责往下移动一直接收a、b中过来的元素
    //上面是准备环节，下面是归并的主体
    while(pa <lista->data + lista->length && pb < listb->data + listb->length){  //这个循环条件是pa、pb均没有遍历完对应的表
        if(*pa < *pb){
            *pc = *pb;           //pa和pb所指的当前元素谁大谁到c里面
            pc++;  pb++;         //这两句话是让指针往下走，pb当前指的已经并进c了，当然要往下走一位。pc一直在自增，因为c一直在延长
        }
        else if(*pa >= *pb){      //其实这句就是else就行了，但是我们要演示条件的含义
            *pc = *pa;
            pc++; pa++;          //注意不管哪个表的元素这一轮归进c中，pc永远是往下走，但是a表当前元素拉进来，b表的指针pb停着不动。反之亦然
        }
    }
    //至此，这一个while{}循环就完成了归并的大部分内容。他结束的条件是有一个表已经全部并进c中（肯定会发生），接下来只要把剩下那个表直接照搬进来即可
    //但是，剩下的表是哪一个呢？我们可以通过条件语句判断哪一个表剩下，然后把它直接并进c表中，但是不要这样，注意下面这个技巧
    //技巧：
    while(pa <lista->data + lista->length){
        *pc++ = *pa++;         //上面那个三语句的简写版
    }
    while(pb < listb->data + listb->length){
        *pc++ = *pb++;         
    }
    //至此，归并就完成了，上面三个while就是归并的算法的核心和主体，并且下面两个while是一种省的搞条件判断的技巧，两个while只有其中一个会运行
    //然后再补一个细节，就是把c表的长度给改一下,谁都知道，c的长度是a和b长度之和
    listc->length = lista->length + listb->length;     //这样就完全完成了归并两个有序表的算法
}
```
这个代码使用移动的指针类型实现，也可以用整型坐标来实现的。代码如下，这是后面归并排序算法中很重要一部分。
```c
void merge(SList * lista, SList * listb, Slist * listc){
    int i = 0, j = 0;  //地址偏移量，就是移动的数组下标，i对应表a，j对应表b
    int cindex = 0;    //对应表c的坐标
    while(i < lista->length && j < listb->length){
        if(lista->data[i] > listb->data[j]){
            listc->data[cindex++] = lista->data[i++];
        }
        else{
            listc->data[cindex++]  = listb->data[j++];
        }
    }
    while(i < lista->length){
        listc->data[cindex++] = lista->data[i++];
    }
    while(j < listb->length){
        listc->data[cindex++]  = listb->data[j++];
    }
    listc->length = cindex;     //上述循环完成后，cindex的值刚刚好就是c表的表长，并且i刚好就是表a长度，j刚好就是表b长度
}
```
## 2. 线性表的链式存储结构
线性表的链式存储结构就是链表，链表在内存中是散的，物理位置上没有关系，但是每一个内存块间串起来，并且每一个块都知道下一个块的位置，因此可以依次向下按顺序访问。  
链表是按照单个单个的结点串起来的，而这样一条长链我们一般只知道一个在链头的指针，我们对链表的一切访问、操作都得通过这个头指针往下走，某种意义上，这个头指针可以说是链表的“名字”的存在，就像 `int a[3] = {5, 2, 0}` 后我们可以说这个数组是`a` 。  
链表是按结点或者存储单元来组织的，所以我们只需定义它单个结点的数据类型。先定义一下。
```
Typedef struct node{
    int data;             //这是数据域，数据类型不妨用int 
    struct node * next;   //这是指针域，指针域类型就是这个结点自己的类型，指向下一个
}Linkedlist;              //我们把它称作Linkedlist， 是考虑到它链表本身也是用Node型指针来表示的，命名这个根本不重要
```  
反正我们知道他是**数据域和指针域**就行了，数据域存数据，指针域指向下一个结点，当然最后一个节点指针域就是NULL了。

下面直接定义操作和解释大概原理，_至于代码实现我们就别管了。_  
我们要介绍操作，干脆先讲插入中的头部插入。假如已经有一条链表Linkedlist * list, list已经有不少结点了，现在要求我们把一个新结点插在链表头部，成为新的第一个结点。
为了做这件事，我们搞一个函数 `void Insertstart(Linkedlist* list, int value)`
> 这个函数能够建一个新的结点，储存值value，并插入到链表头。怎么实现先放一边，我们现在要这样想：  
> 链表是长什么样的？如果是每一个结点依次连接，头指针直接指第一个结点，那么我们把这个新结点插进去，头指针就指向了新结点，这就意味着：头指针改变了。头指针改变是件大事，这又牵扯到C语言函数传参的问题。我们用最俗的方式告诉你这里会出问题：刚才说头指针是链表的“名字”，你把人名字在函数里改成了别的，肯定会面临一些问题。
> >细说就是，函数`Insertstart`外面主函数里的头指针(假设变量名是head)`head`,和调用`Insertstart(head, 7)` 传到函数里 的head根本不是同一个head，而是一份拷贝
> >函数`Insertstart`里面的那个`head`指向了新的_第一个_结点(注意我的用词)，而函数外面主函数里的`head`根本没有改变。内存里面，新的结点7确实是插入到链表的头部去
> >并且成为了链表最开始的结点，但是主函数的head没有指向它，而是仍然指在原来的那个位置，也就是现在的第二个结点。而刚才传参拷贝的那份`head`的的的确确改指到新结点
> >“7”了，但是函数调用一结束它就没了，没有对外面也就是主函数内造成任何影响。这就导致，新结点接上去了，但是链表头指针没变，因此，我们头插的新结点仍然找不到。 
>  
> 上面说这些是为了引出头结点的概念。**从这里开始看**，总之，链表要有头结点，使得插入、删除等操作不必考虑头指针改变，任意位置操作都是统一的。  

带头结点链表：设置一个不储存值的结点，所有有意义的结点都接在它的后面，并且头指针指向它。这样，头指针永远不会有考虑改变的问题，所有的操作是统一的。

### 链表操作
链表的的插入、删除、修改，无外乎**找到位置，修改指针**。修改指针的过程就是注意，指针是我们访问一个结点的唯一途径，指针绝对不能丢  
比如说 A->B要把C结点插入到A，B中间，我们首先要找到A（所谓提前一个位置）,肯定是C先指向B(我们可以访问B，通过A可以访问B),然后A指向C。假如A先指向C，然后B就丢了。进行不下去了。所以操作过程中注意不能出现把访问的途径给搞没了，待会就访问不了的情况，一般就不会选错。

**重点：链表的特点是访问任何一个都得依次按顺序访问下来，不是随机访问，访问的代价是O(n). 而链表在插入、删除的时候不必移动大量元素，而是修改一下指针就完成了，时间复杂度也是O(n)** (两个结构优缺点分析)

### 重要算法：快慢指针法
快慢指针法用于一些链表的处理，意思就是出两个指针，一个走前一个走后，给四道例题看看。
1. 如何判断链表是否有环           两个指针一个每次走两步，一个每次走一步，如果有环的话，快的在环里肯定追上慢的
2. 如何找到链表的倒数第m个元素     两个指针从起点出发，一个先走m步，然后两个再同步调走，直到前面的到达了最后一个，后面的就在倒数第m个
3. 线性链表中间位置的元素         两个指针一个每次走两步，一个每次走一步，快的走完，慢的自然走到中间
4. 求两个单链表是否交叉           测出两个表的长度，长的和短的，长的那个先让指针走gap步（gap是表长之差），然后两指针同步调往下走，相等的时候就是交点

### 算法：链表倒序
链表倒序的核心是头插法，我最早想的头插法是逐一遍历原来链表，然后把每一个元素头插法插入一个新的链表，但这样子空间复杂度O(n),实际上O(1)就够了。  
做法：一个链表出来，我们就要用它已有的空间，把头指针直接当成一个新链表，开始头插法建表。具体的操作步骤如下：
```
一、把第一个元素的结点标为p，然后断掉头结点指向空。
二、将头结点看成一个新链表，p即后面所有结点看成原始的链表。    
三、开始如下循环：把原始链表中的每一个元素依次头插到新链表中即可。
```
**注意**；首先把第一个元素的结点标为p，否则断开头结点，使头结点成为新链表的时候，原来的链表就丢失了。其次，这一个过程想要实现p指的那边链表逐一头插到新链表里，实际的代码实现中还需要引入一个q指示下一个元素，否则p插走之后链表就丢了。 ppt里的代码和图片不清楚，其实上就是头插法。


## 3. 静态链表
静态链表就是，在内存空间上，他是连续的内存空间，但是在顺序上，他顺序和地址的顺序没有关系，他是按链表式的来的，每一个结点告诉你下一个结点是谁。所以我们建静态链表是按照单个结点来组织的，一次申请一段结点类型的连续内存空间（就是申请一个节点类型的数组），、静态链表的单个结点内包含数据域和一个`int`型变量next，叫所谓的“指针域”，它指示下一个节点的地址坐标，比如next是3告诉你下一个节点坐标3的内存空间。 在Huffman树那有应用。  
如果要在一段已经告诉你的结点表中把静态链表串起来，其实是很简单的，就按着每个结点告诉你的`下一个位置`找下一个结点就行了。

## 4. 栈
所谓栈和队列，都是操作受限的线性表，上面的两大种线性表，规定一些相应的操作规则，就是栈或队列。比如栈，就是规定只能在尾部插入，在尾部删除元素，“后进先出”的原则。
实现一个栈是很简单的，随便两句`int stack[100]; int top = -1;` 就定义好了一个空栈，最多能存100个元素。入栈操作很简单，一句`stack[++top] = 3`就把3压入栈中，一句`int a = stack[top--];` 就完成了把栈顶元素弹出并赋值给a。
**栈的应用**：函数的递归调用就是最常见的栈的应用，其实上系统帮我们维护了系统栈来实现递归功能。很多算法我们如果要采用非递归形式，就得自己实现栈。
### 栈的应用：表达式求值 
#### I 中缀表达式转换成后缀表达式
从左开始扫描一个中缀表达式，遇到数字，就直接输出；遇到一个运算符，就涉及栈操作。遇到一个运算符，就进栈，就得进栈。但是要保证栈顶元素的优先级高于其他栈元素，否则先退掉栈顶运算符。换言之，遇到运算符，先看栈里是什么，如果栈顶有一个比他更优先或者同级别的操作符，都退栈输出再压栈。此外，遇到`(`，我们先让他进栈，此后继续，仍按照前面规则做，当遇到`)`时候，一直退栈输出直到`(`退栈，但不要输出括号。
#### II 后缀表达式计算
从左向右扫描一个后缀表达式，遇到数字，就进栈放着，遇到一个运算符，就从栈里弹出两个数字，做该计算，并把得到的结果压回栈里。当表达式完全结束时，栈里面会有且仅有一个元素，这个元素就是我们的计算结果。  

**注意：记住以上流程   还有，代码实现就别管了**
## 5. 队列
规定只能从尾部插入，头部删除，就成为队列，队列讲究“先进先出”。如果用指针实现队列，就搞两个指针一个头指针尾指针，插入在尾指针那里操作，删除就在头指针那操作。如果用数组实现队列（顺序队列），就指定两个整形游标指示头和尾的坐标，就像栈的那个top一样。但是会有问题就是一个长条数组要是一直出队列，即`front++`,最后发现队列的空间不够用了，称为假溢出。我们直接看他的解决方式，就是“循环队列”。  
循环队列好像是把顺序空间的头尾接起来，让`front++`加一圈会回到0位置，实际上存储空间是接不起来的，我们是通过**取余**的方式来实现的循环，所以说很巧妙。比如说我们队列最长是8，那么数组的下标为0-7，把头、尾坐标都加上 `%8`, 即出队列操作为 `front = (front+1)%8`,那么当他达到7（最大有效下标），下一个一代入就发现是0了，这样一直加的话永远在0到7之间循环，这就实现了循环模式。  
循环队列如何判断队列满呢？这是我们自由规定的。我们规定：`front == rear`(rear是表尾位置)是表空，rear指的位置其实不是真正的队列尾部，而是队列尾部的下一个位置，进队列操作就是（假设申请的数组是queue） `queue[rear++]`, 规定当rear再往下走一步就追上front的时候为队列满状态， 即 `front == (rear + 1) % 8` 规定为表满。 这段演示里的 8 可以换成我们为队列申请的顺序存储空间个数Maxlenth（或者叫他数组长度、最大长度）  
**在上面规定的条件下**，已知front、rear，求队列长度： 公式为` (rear + maxlength - front ) % maxlength ` 

## 6. 数组
数组本身其实就是对顺序存储空间做快捷访问与操作的一个实现，高级语言提供好了这个功能，并且我们都前面都已经用去实现其他线性结构了。C语言中，数组是**按行存储**的。重点有多维数组、矩阵存储。

多维数组：多维数组其实上就是数组的数组，也可以叫它多层数组，我们把它想象成了条形，其实他也是线性的，多维数组的高维度层次的走一步走一整个下一维度。数组反正依赖于一个基地址和一个偏移量， `a[b] == *(a + b)`，a是数组名，是基地址，就是a[0]的地址，b就是偏移量。当多维数组转换到线性的地址位置时，公式为：  
   `a[i][j][k] = &a[0][0][0] + k * 1 + j * d1 + i * d2`
这个公式的规律就是，基地址就是全维度为0， 然后加偏移量，一维偏移量直接加，第二维偏移量要乘数组的第一维长度（因为这是他偏移一步的偏移量），第三维偏移量要乘数组的一、二维度量（因为这是它第三维度便宜一步的偏移量），  总之第n维的偏移量要乘上数组前n-1维的各维度长度.   
此公式来自C标准的定义。
**矩阵的压缩存储：直接记对应公式**
##### I 对称矩阵压缩存储
n阶对称矩阵有$n^2$个元素，去掉对角线上的n个，剩下的 $n^2-n$ 个是对称的，实际上只有 $\frac{n^2-n}{2}$ 个，加上对角线n个，其实是 $\frac{n^2+n}{2}$ 个，所以只需要 $\frac{n^2+n}{2}$ 个存储空间就可以存下这个对称矩阵。也就是说，用一个这么长的一维数组存，第k个元素与a\[i]\[j](i>=j)对应关系如下：
$$k=\frac{i(i-1)}{2}+j$$
如果i<j，完全可以把他们互换，反正是对称的没有影响。  即：大的乘大的减一，除以二加小的。**其实他的实质是，因为我们只存了半边矩阵，我们做的就是大的标-1，从1加过来（1看图就马上理解为什么要从1加到（比大的少1），然后加上小坐标（小坐标其实就是补它大的扣去的1）**  即：1加到（大的减1），再加小的  
##### II 带状矩阵
带状矩阵只存储带里的元素，带外全为0不管。带状矩阵的带宽S看第一行，去掉第一个后还剩几个，S就是几。先确定S，然后代公式。带状矩阵的的 $a_{ij}$ 换成一维存储对应位置的公式为： $$a_{ij} = a_{11} + [(2S+1)(i-1)+(j-i)]$$
其实ppt里公式中括号外还乘以一个L，那个L说是什么每个数据的字节数，又说L=1，怎么回事就不管了。

## 7. 串
串就是字符串，串的重点有匹配算法，暴力匹配和KMP算法。  
匹配：如果有两个串，一个串可能是另一个的子串。也就是说，一个串是主串，另一个串是模式串，要判断模式串是不是主串的子串，也就是是不是出现在了主串里面。
#### I 暴力匹配（朴素的模式匹配、BrouteForce算法）
算法思想：模式串T的第一个字符依次和主串的第一、第二...个字符对齐往下比较，直到匹配成功。  
回溯：BF算法中所谓的的回溯，就是因为我们通过两个指针去操纵比较过程，一个指针在主串上，一个指针在模式串上。当主串的指针往下走了之后，发现比较失败，那么下一次比较主串上的起点就是本次比较的起点的下一个，主串这个指针要往回走回到那个位置，所以叫做回溯。回溯了多少呢？他走出去的步数和模式串走出去的步数一样，模式串那个偏移量是多少，他就回退多少到该次的起点，再往下走一位，就到了下一轮的起点。所以公式是： $i=i-j+1$  (i是主串指针的位置号，j是模式串指针的位置号)  
注：如果非要考什么回溯多少，就是上面那个公式。 其实上回溯就是个找下一次起点的过程，减去全部偏移量就回到起点，再往下走一步就是下一个的起点，就这样理解记忆。 但是回溯不算什么难点，我们不过是在用单根指针在主串上操纵的时候会要考虑一个回溯，用别的方式找下一次起点，比如我把每次循环定一个不动起点号i，每循环一次i++，那就无所谓回溯了。

#### II KMP算法
上面之所以非要单根指针在主串上游动操纵，研究什么回溯，其实是为KMP算法准备的。在KMP算法里，也有这样一根指针p在主串上游动并操纵比较，但它的特点是：永远不会往回走，时间复杂度O(n)的。p持续的向下移动，移动完整个主串，匹配也就完成了。  
KMP算法的原理：先准备一个next数组，在这个数组的帮助下，每次匹配失败时，直接根据next数组从模式串某一个元素开始继续往下比较，这样的方法经证明是可行的。  
KMP算法不好实现，但是要我们理解KMP算法，人工写出next数组还是不难的.  
**next数组**：如果有子串T，主串S，子串中第j位失配了，那么说明一件事：`T[0]`到`T[j-1]` 这j位字符配对都成功了。那么：子串T上已经匹配成功的前j个中，如果有一个前缀刚好与后缀相等的情况，即：存在k，`T[0]`到`T[k-1]`这k个 和 `T[j-k]`到`T[j-1]`这k个 是完全一样的片段， 就可以从`T[k]` 开始，直接和主串上当前位置继续往下比较。  
**next数组的含义**： 所以，`next[j]`存储当`T[j]`和主串失配时，该从`T[几]`开始继续比较。  
**next数组的生成和优化**: 1. `next[0]`一律规定为-1，表示当`T[0]`都错配了，就只能主串往下移动一位继续比较了。 2.其余的`next[j]` 就到`T[0]`至`T[j-1]`这一段中找相同前后缀长度，即前k个与后k个完全一样，那么`next[j] = k`. 3. 优化，如果`T[j]`与`T[k]`相等，那么做这样的优化`next[j] = next[k]`。这个优化可以连续做，如`next[6]=next[3]=next[0]=-1`  
**注**：理解上面的这个next数组生成过程，第一是根据next数组的含义。next数组的含义就是说，如果这一位匹配失败，下一个换谁来匹配。只要拿住这个含义，就可以写出next数组来。 第二，计算机中只需要实现前2步，就可以完成kmp算法。 第三，理解这个优化过程：如果`T[k]==T[j]`,当`T[j]`错配，找`next[j]`来比，`next[j]`的值是k → 由于`T[k]==T[j]`，`T[k]`匹配肯定失败，找`next[k]`来比。  这样一个过程，就简化成`T[j]`匹配失败，直接让`next[k]`来比。 理解这一个，也是要紧紧抓住next数组的含义来做。  
>例题："abcac"求模式函数(模式函数就是next数组)
>```
> next[0]=-1,  next[1]=0(相同前后缀长度0)  next[2]=0(理由和上一条一样)   
> next[3]=-1(先是next[3]=0,发现0和3号位都是a，那0号位的a去匹配肯定也失败,直接优化成-1)
> next[4]=1(前缀a和c前面那个后缀a匹配上了,相同前后缀长度为1。发挥想象，下一次把模式串往右移，相同前后缀a对上,所以下一次直接从b开始匹配)
>```
看下面两张手写的笔记
![page1](/tupian/1t1.jpg)
![page2](/tupian/1t2.jpg)

KMP算法的代码()
```c
int kmp(char* s, char*t, int next[]){
    int index = 0, i = 0, j = 0;  //定义三个变量，index是待会匹配到的成功位置首位坐标，如果匹配失败就得更新它。i是主串上游标，j是子串上游标
    while(s[i]!='\0' && t[j]!='\0'){
    //循环比较，循环条件是主串和子串都没有比到结束。如果比到结尾了就说明比较结束（可能成功也可能失败），应该结束循环并返回
    //下面写主体，写循环就抽象到自己正处于循环中间的某一次。首先是比对的情况：如果比较成功，就同时比下一个
        if(s[i] == t[j]){
        //比较成功，两个串的游标都往下走，进行下一轮
            i++;
            j++;
        }
        else{
        //其他情况，就是比较不成功发生在了j位上
        
          //首先要更新index，index的新值实际上是待会t[0]所对应的新值，所以用index = i - j (在j更新后做)更好
           // index = index + j - next[j]; 老师ppt的，我们不用了，太晦涩
           
            //现在要让j更新成next[j]，下一次比较由新的j位来比。但他如果是-1，就表示主串上的i要往下走一位，与子串0号位开始继续比。所以还要判断
            if(next[j]==-1){  
                i++;       //next[j]为-1的情形，说明主串下移，模式串从0开始
                j = 0;
                index = i;  //这里j 直接从0开始，i也已经往下移动一位完了，直接index就是i，新的起点
            }
            else{
                //失败情况且next不是-1, 即更新j为next[j]，说明下一轮i不动，直接拿next[j]上去比
                j = next[j];
                
                index = i - j;  //j是j游标自己关于t[0]的偏移量，减了j就知道t[0]对应几号位置了
            }
            
        }
    
    }
    //至此while循环结束了，然后我们目前尚不知道匹配是否成功，所以做判断。我们不知道while是因为谁走完了而退出的，但我们只需判断t[j]是否走到结尾就知道匹配是否成功。
    if(t[j] == '\0'){
        return index;    //当t[j]结尾说明匹配成功，此时index就储存着子串出现在主串中的位置
    }
    else
        return -1;        //失败的情况，但是注意不能返回0，因为0虽然表示false，但在这里int型 0值是有效的index返回值,只能拿-1来标记匹配失败
}
```
上面就是kmp比较的主体，但是我们还缺一个算next数组的方法。太难了，直接把ppt复制过来。这个函数直接得到我们手算`next[]`第三步优化后的结果。
##### kmp算法中next数组的生成
老师ppt代码：
```c
void GetNext( const char *T, int next[] ) 
{ // 求模式串T的next函数值
      int j = 0, k = -1; 
      next[0] = -1; 
  while ( T[j] != '\0' ) 
  { 
      if ( k == -1 || T[j] == T[k] ) 
      { 
          ++j; ++k; 
          if ( T[j] != T[k] ) 
              next[j] = k; 
          else 
              next[j] = next[k]; 
      }// if
      else 
          k = next[k]; 
  }// while
} // GetNext
```
###### 代码先不看，我们分析一下他的一些特点:
1. 设置了两个游标或者'指针'，分别是k和j
2. `next[]`数组的修改完全由`j`来完成，并且每次一定是`j++`后绑定出现`next[j]`位置的修改,`j`不会回溯，不会用`j`来访问next数组的值。
3. `k`游标只能用于访问`next[]`数组，并且`k`可以向前增加也可以回溯。
4. 换言之， `j`是只写不读，`k`是只读不写。 `j`相当于对`next[]`的只能写入探头， `k`相当于对`next[]`数组的只能读取探头。 `j`不倒退，进一步写一个,`k`不一定。

如何得到next数组，上面算法到底什么逻辑呢？他们的关系是这样的：
1. 如果j走到了现在他所在的位置，那么说明`next[0]`到`next[j]`都确定好了。
2. k是用来给j提供确定`next[j]`值的信息的。k在任何一个位置，说明`next[0]到next[k-1]`和`next[j-k]`到`next[j-1]`完全一样。然后每次判断k和j所指位置一不一样，一样的话，他们各自纳入前后缀中，即变成了`next[0]到next[k]`和`next[j-k]`到`next[j]`完全一样。如果这样的话，就可以说明`++j`位匹配错误要从`++k`位开始比较。这就有了`next[++j] = ++k`这句代码。
3. 如果k和j位置判断发现位置不一样，那么从起点到k-1位的这段序列就没有作用了，（对我们要写++j位置的没有任何参考作用了），所以接下来k得改成`next[k]`，可以找到上一个有效前缀所对应位置（真的是这样，可能自己画图会好理解这个意思，而且有点像在已生成好next数组的片段上和后面的序列做kmp算法比较，有相似性）,k更新(回溯)后继续上面过程。

分析了这个关系，其实就大致把next数组生成算法的思想搞会了。思考技巧：这是一个动态的过程，假如已经到了中间某一步，思考下一步该怎么做。高度抽象，不要形象在某一次或者第几次。 

下面自己写一下getnext函数，就根据上面分析的思路写。
```c
void getnext(char * t, int next[]){
    //Step 1  首先要有两个“探头”
    int k = -1, j = 0; 
    
    //Step 2 在进入循环前，先完成一个基础情况来启动循环
    next[j] = -1;     //这个基础情况先写，也是作为循环的一个启动
    
    //Step 3 写循环过程，这个过程里就关注是“某一次”，关注动态的过程
        //1. 首先，循环条件是什么？是next写完就结束了，也就是j走到结尾。 
     while(t[j]!='\0'){
        //2. 上来我们会拥有j和k两个探头，他们在某个位置（别管具体在哪）,并且上一轮任务刚完成，j和k就在那，我们现在要先比一下，看是否满足下一次写入的条件
        //注：下一次写入的条件就是来自上面的2, 如果j位置和k位置的值一样，说明`next[0]到next[k]`和`next[j-k]`到`next[j]`完全一样，则可以写入j下一位的next值
        //在要考虑，当k的值可能是-1，因为我们初始值设的-1，否则不能启动循环。k = -1是一个合法值，表示的是这一轮没有任何相同前后缀了。
        if(k == -1 || t[j] == t[k]){
           //满足j和k位置相等的情况，此时j的下一位的next可以写入。j和k位相等，++j和++k后，此时的j位置若不匹配就拿k位置来匹配，故next[j] = k
            next[++j] = ++k;
        }
        //如果不满足的情况，此时k位置不满足可写入条件，那就去上一个可能满足的地方，其实就是next[k]
        else{
            k = next[k];
        }
     }
}
```
这个getnext可以生成next数组。和老师ppt复制的比较会发现，我们少了一个条件判断，没有写什么` next[j] = next[k]`。两个getnext函数有什么不同呢？  
从效果上看，上面那个GetNext函数生成的next数组是我们第3步优化后得到的效果。 而我们这个getnext函数是做完1、2两步得到的效果。计算机只实现1、2两步即可完成kmp算法。

优化的原理：当判断可以写入时，我们第一个步骤是`j++;k++;`将j和k都往下移一位。然后我们不直接写`next[j] = k`，而是判断一下`t[j]` and `t[k]`是否相同，如果相同，_说明`t[j]`待会比完了失配就是`t[k]`来比，`t[k]`肯定匹配失败，然后`next[k]`来比，干脆就优化成直接`next[k]`来比。_ 所以直接`next[j] = next[k]`。  
注：这个优化因为是从左往右生成，所以遵循`next[j] = next[k]`就可以出现连等。而不是人工生成那样逐个优化，因此没有出现`next[6]=next[3]=next[0]=-1`这种，但是能实现这个功能。 
###### kmp算法完整代码
[点击这里tp过去](/kmp.h)

## 8. 作业题目
#### 1、大O记号题
给出表达式，求是O多少的题。 做法：直接找最大项，系数扔掉。注意N！是O（ $N^N$）  
给出代码，求复杂度是O多少。 做法：一层线性的循环就是O(n)，外面再来一层就变成O( $n^2$)，那要是里面套一层100次的循环，那是常数次，常数次就是O(1)。
#### 2、多维数组
作业题：
> 设数组A[50][80]，其基地址为2000，每个元素占2个存储单元，以行序为主序顺序存储，回答下列问题：
>    (1) 该数据组有多少个元素？
>    (2) 该数组占用多少存储单元？ 
>    (3) 数组元素a[30][30]的存储地址是多少?
数组元素`A[m][n]`元素个数就是 $mn$，每一维个数乘就对了。 存储单元，每个元素可能是多个存储单元来存储，并且用第一个单元的地址表示一个元素的地址。  
求任意`A[i][j]`的地址号，就用上面讲的公式 `a[i][j][k] = &a[0][0][0] + k * 1 + j * d1 + i * d2`，这个公式其实是来自于，对`int A[row][colunm]`取指针型p = A ，也就是数组的基地址，那么A[i][j] = *(p + i*column + j) 他内在就是这样子的，这不是我们推的数学公式，而是c标准的定义。所以不要去纠结什么`A[30]`是第几个，里面是31个还是31行。(公式是对指针型而言的，我们得每个偏移量把元素的size乘上)

## 9 算法设计例题
### 1 归并有序序列(上面有)
### 2 数组循环移位
设将 n (n>1) 个整数存放在一个一维数组 R 里。设计一个**时间和空间**两方面都尽可能高效的算法。将R中保存的序列循环左移 p(0<p<n)个位置。  
例如将 12345678 左移3位，变换成 45678123. 

**算法思想：将序列分为AB两段，A和B分别颠倒，再将整段颠倒。** 这个算法就可以把AB变成BA，且时间O(n)空间O(1)，都很高效。  
代码描述：
```c
// 数组的循环移位
//读入一个数组，一个整数m，把数组循环左移m位
//算法思想：只需o(n)时间和o(1)空间，将左边m位和右边片段分别颠倒，然后再整体颠倒

//交换两个数值的函数
void swap(int * a, int * b){
    int temp = *b;
    *b = *a;
    *a = temp;
}
//颠倒序列的指定片段
void reversearrey(int arrey[], int start, int end){
    int i = start, j = end;
    while(i < j){
        swap(&arrey[i++],&arrey[j--]);
    }
}
//循环移位算法的主体
void xunhuanmove(int arrey[], int n, int m){
    reversearrey(arrey, 0 ,m-1);
    reversearrey(arrey, m, n-1);
    reversearrey(arrey,0, n-1);
}
```

### 3 链表交叉、求交叉链表交点
判断链表交叉：如果两个链表是有交点，那么他们的终点必然是同一个。各自遍历到最后结点，判断是不是同一个结点即可。  
**核心思想：快慢指针法**

### 4 设辅助数组，用空间换时间
例1.给定一个含 n（n>=1）个整数的数组，请设计一个在**时间上尽可能高效**的算法，找出数组中未出现的最小正整数。例如，数组{-5,3,2,3}中未出现的最小正整数是1；数组{1,2,3}中未出现的最小正整数是4。  
算法思想：设一个n+1大小的辅助数组，全初始化成0，扫描一次整数数组，当遇到正整数i，就把辅助数组下标位i的元素置1.之后扫描辅助数组，遇到第一个正整数下标且为0的，下标即为所求最小正整数。

例2. 用单链表保存 m 个整数，结点的结构为: data link，且|data|≤n(n 为正整数)。现要求设计一个**时间复杂度尽可能高效**的算法，对于链表中 data 的绝对值相等的结点，仅保留第一次出现的结点而删除其余绝对值相等的结点。例如，若给定的单链表 head 如下.  
21 -> -15 -> -15 -> 7 -> 15  
则删除后：  
21 -> -15 -> 7   
算法思想：算法的核心思想是用空间换时间。使用辅助数组记录链表中已出现的数值，从而只需对链表进行一趟扫描。 因为|data|≤n，故辅助数组 q 的大小为n+1，各元素的初值均为0。依次扫描链表中的各结点，同时检查 q[|data|]的值，如果为 0，则保留该结点并令 q[|data|]=1;否则，将该结点从链表中删除

### 5 线性链表环路
问题1：如何判断单链表中是否存在环？  
这步很简单，用快慢指针法，一个步长1，一个步长2，若无环必然不相遇且会走到出口，若有环必然相遇。

问题2：若存在环，如何找到环的入口？
设链起点到环入口点间的距离为 x，环入口点到 fast 与 low 重合点的距离为 y，又设在 fast与 low重合时 fast 已绕环 n 周（n>0），且此时low移动总长度为 s ， fast 移动总长度为 2s ，设环的长度为 r，则 $$s+nr=2s$$又有 $$s=x+y$$ 会解出 $$x=nr-y$$
现设一指针 p1 从链表起点处开始遍历，指针 p2 从 encounter 处开始遍历,p1 和 p2 移动步长均为 1, p1 移动 x 步时， p2 也移动x步， 而 $x=nr-y$，这个关系说明p1与p2必定在入口处相遇。  
**简单讲**，相遇处和起点到环入口的距离一定相等。

### 6 划分类
把奇数放前偶数放后、负数放前正数放后，都涉及划分，受快速排序的启发，设置左右游标来完成。

例1.将数组中所有的负数放在正数之前，亦可理解为数组的左端元素值均小于0，而右端元素值均大于或等于0。  
算法思想：令游标 L 从左（L=1）向右扫描，越过key小于 v的记录，直到`A[L]` ≥v 为止；同时令游标 R 从右开始向左扫描，越过大于等于 v 的记录,直到`A[R]`＜v 的记录`A[R]`为止.若L>R（L=R+1），成功划分，L是右边子序列的起始下标。若L<R, 则swap( A[L].data, A[R].data )。重复上述操作，直至过程进行到L>R（L=R+1）为止.

例2. 奇数放偶数前面，代码描述
```c
// 对于一个序列，把把奇数和偶数划分，奇数在前偶数在后
void oddevenpartition(int arrey[], int n){
    int p = 0, q = n - 1;
    while(p < q){
        while(arrey[p] % 2 == 1) p++;
        while (arrey[q] % 2 == 0) q--;
        if(p < q) swap(&arrey[p], &arrey[q]);
    }
}
```

### 7 左右游标搜索
例.输入一个已经按升序排序过的数组和一个数字，在数组中查找两个数，使得它们的和正好是输入的那个数字.  
算法思想：1)	让指针指向数组的头部和尾部，相加，如果小于M，则增大头指针，如果大于则减小尾指针。 2)退出的条件，相等或者头部=尾部

